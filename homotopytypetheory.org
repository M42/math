#+TITLE: Homotopy type theory
#+DESCRIPTION: Homotopy type theory book

#+SETUPFILE: config.setup
#+SETUPFILE: essay.setup
#+LANGUAGE: en
#+OPTIONS: toc:nil
#+TODO: TODO WIP | DONE

* Macros                                                             :ignore:
#+latex_header: \newcommand\ap{\mathsf{ap}}
#+latex_header: \newcommand\apd{\mathsf{apd}}
#+latex_header: \newcommand\refl{\mathsf{refl}}
#+latex_header: \newcommand\id{\mathsf{id}}
#+latex_header: \newcommand\transport{\mathsf{transport}}
#+latex_header: \newcommand\happly{\mathsf{happly}}
#+latex_header: \newcommand\funext{\mathsf{funext}}
#+latex_header: \newcommand\proj{\mathsf{pr}}
#+latex_header: \newcommand\pr{\mathsf{pr}}
#+latex_header: \newcommand\idtoeqv{\mathsf{idtoeqv}}
#+latex_header: \newcommand\ua{\mathsf{ua}}
#+latex_header: \newcommand\isSet{\mathsf{isSet}}
#+latex_header: \newcommand\isProp{\mathsf{isProp}}
#+latex_header: \newcommand\Set{\mathsf{Set}}
#+latex_header: \newcommand\Prop{\mathsf{Prop}}
#+latex_header: \newcommand\fnot{\mathsf{not}}
#+latex_header: \newcommand\LEM{\mathsf{LEM}}
#+latex_header: \newcommand\trunc[1]{\left\lVert#1\right\rVert}
#+latex_header: \newcommand\isContr{\mathsf{isContr}}
#+latex_header: \newcommand\ishae{\mathsf{ishae}}
#+latex_header: \newcommand\qinv{\mathsf{qinv}}
#+latex_header: \newcommand\fib{\mathsf{fib}}
#+latex_header: \newcommand\biinv{\mathsf{biinv}}
#+latex_header: \newcommand\linv{\mathsf{linv}}
#+latex_header: \newcommand\rinv{\mathsf{rinv}}
#+latex_header: \renewcommand\succ{\mathsf{succ}}
#+latex_header: \newcommand\isequiv{\mathsf{isequiv}}
#+latex_header: \newcommand\isHinit{\mathsf{isHinit}}
#+latex_header: \newcommand\isEmbedding{\mathsf{isEmbedding}}
#+latex_header: \newcommand\isSurjective{\mathsf{isSurjective}}
#+latex_header: \newcommand\pair{\mathsf{pair}}
#+latex_header: \renewcommand\loop{\mathsf{loop}}
#+latex_header: \newcommand\base{\mathsf{base}}
#+latex_header: \newcommand\N{\mathsf{N}}
#+latex_header: \renewcommand\S{\mathsf{S}}
#+latex_header: \newcommand\merid{\mathsf{merid}}
#+latex_header: \newcommand\istype[1]{\mathop{\mbox{$\mathsf{is}$-$#1$-$\mathsf{type}$}}}

* Part I
** I.1. Type theory
*** I.1.1. Type theory versus set theory
**** Judgements and rules
Set theory is not only about seta but also about the interplay between /sets/
and /propositions/ of first-order logic, the system where sets are formulated.
In contrast, type theory does not need to be formulated inside any 
superstructure such as first-order logic. It is its own deductive system.

First-order logic is based on only one kind of judgment: whether any
given proposition as a proof; but in type theory, the basic judgment
is $a : A$, where $a$ is an element of the type $A$. Although it could
be seen as an analogous to $a \in A$ in set theory, the difference
resides in that $a \colon A$ is not a proposition but a judgment of
the theory. In particular, we cannot disprove those judgements and we
cannot talk about an element $a$ without specifying its type.

**** Propositional equality
Equality here is not a proposition but a type. Given $a,b : A$, we can define
the type $a =_A b$; we say that $a$ and $b$ are *propositionally equal* when this
type is unhabited.

**** Judgmental equality
*Judgmental equality* or *definitional equality* is an equality judgment
given by definitions: it can be decided expanding out the definitions. 
We write it as $a \equiv b$ and we introduce definitions as $a :\equiv b$.

**** Judgments of type theory
Type theory will be a system based on two forms of judgement

 * $a : A$, meaning $a$ has type $A$.
 * $a \equiv b : A$, meaning that $a$ and $b$ are definitionally equal.

**** Contexts
A *context* is a collection of assumptions in which a judgment may depend on.

# It can be thougt as a parameter space (?)
# https://en.wikipedia.org/wiki/Parameter_space

**** Rules and axioms of type theory
Rules of type theory can be grouped into type formers, procedural ways
to construct types. Usually, no axioms are necessary in type theory.

*** I.1.2. Function types
**** Functions
Given types $A,B$, $A \to B$ is the type of *maps* or *functions* between them.
Functions are a primitive concept of type theory; given $f : A \to B$, it can
be applied to $a \colon A$ to obtain $f a : B$.

***** Constructing functions
Given $\Phi$, an expression of type $B$ assuming $x : A$; we can define a function
as

\[
f(x) :\equiv \Phi,
\]

and also as a \lambda-expression, written as

\[
(\lambda (x:A) . \Phi) : A \to B,
\quad
\text{ or even }
\quad
(x \mapsto \Phi) : A \to B.
\]

**** \beta-reduction
*\beta-reduction* is a computation rule defined by

\[
(\lambda x. \Phi) (a) \equiv \Phi',
\]

where every ocurrence of $x$ in $\Phi$ has been replaced by $a$ in $\Phi'$, in a way that
the binding structure is preserved; maybe renaming variables.

**** \eta-reduction
*\eta-reduction*, often called /uniqueness principle for function types/
is the computation rule defined by

\[
f \equiv (\lambda x. f(x)).
\]

**** Currying
*Currying* is a way to define multiple-input functions as functions returning
partially aplied functions. For example, $f : A \to (B \to C)$ can be applied
to two arguments as $(f\ a)\ b : C$.

*** I.1.3. Universes and families
**** Universes
A *universe* is a type whose elements are types.

***** Russell's paradox
As in set theory, a universe of all types including itself, ${\cal U}_{\infty} : {\cal U}_{\infty}$, is
unsound.

***** Hierarchy of universes
A cumulative hierarchy of universes is defined, where every universe
is an elemtn of the next universe, ${\cal U}_i : {\cal U}_{i+1}$; and all the elements of
a universe are elements of all the higher universes.

\[
{\cal U}_0 : {\cal U}_1 : {\cal U}_2 : \dots
\]

*Typical ambiguity* is the writing style where we omit the level unless
it is necessary.

**** Families of types
A *family of types*, is a collection of types varying over a type
variable $A$. They are functions whose codomain is a universe, $f : A \to {\cal U}$.

*** I.1.4. Dependent function types (\Pi-types)
**** Dependent function types
Given $A : {\cal U}$ and $B : A \to {\cal U}$, we construct the type of *dependent functions*
as $\prod_{(x:A)}B(x) : {\cal U}$.

***** Constructing dependent functions
Given $\Phi : B(x)$, a expression assuming $x : A$, we can use \lambda-abstraction
to write

\[
\lambda x . \Phi(x) : \prod_{(x:A)} B(x).
\]

***** Reductions
\beta and \eta-reductions still hold on dependent functions.

**** Polymorphic functions
A *polymorphic function* takes a type as one of its arguments, and acts on
elements of that type.

***** The identity function
The polymorphic identity function $\mathrm{id} : \prod_{(A:{\cal U})} A \to A}$ is defined as
$\mathrm{id} =& \lambda (A:{\cal U}) . \lambda (x:A) . x$.

*** I.1.5. Product types
**** Cartesian product
Given $A,B : {\cal U}$, the *cartesian product type* $A \times B : {\cal U}$ contains pairs
$(a,b) : A \times B$, where $a:A$ and $b:B$. A function on a product type is
defined by

\[
f((a,b)) :\equiv g(a)(b),
\]

where $g : A \to B \to C$.

**** Unit type
The *unit type* $1$ has a unique element $\star : 1$.

**** TODO Introducing new types
**** Product type recursor
The *recursor* for product types symbolizes the fact that we can define a 
function on a product type only by giving its value on pairs,

\[ \mathtt{rec}_{A \times B}(C,g,(a,b)) = g(a)(b),
\]

where it has type

\[ \mathtt{rec}_{A \times B} : \prod_{C : {\cal U}} (A \to B \to C) \to A \times B \to C.
\]

**** TODO Unit type recursor

**** TODO Product type dependent recursor
**** TODO Propositional uniqueness principle
**** Induction principle on product types
The induction principle on product types has type

\[ \mathtt{ind}_{A \times B} :
\prod_{C : A \times B \to {\cal U}}
\left( \prod_{(x:A)} \prod_{(y:B)} C((x,y)) \right) \to
\prod_{(x:A \times B)} C(x)
\]

and defining equation $\mathtt{ind}_{A \times B} (C,g,(a,b)) :\equiv g(a)(b)$.

**** TODO Induction principle on unit types

*** I.1.6. Dependent type pairs (\Sigma-types)
**** TODO Type-theoretic axiom of choice
**** Example: Magmas
We can define a *magma* as

\[ \mathtt{magma} :\equiv
\sum_{A : {\cal U}} A \to A \to A.
\]
*** I.1.7. Coproduct types
**** TODO Coproduct type
**** TODO Empty type
*** I.1.8. The type of booleans
**** TODO if-then-else
**** TODO Coproducts as dependent types
*** I.1.9. The natural numbers
**** TODO Natural numbers
**** TODO Associativity
*** I.1.10. Pattern matching and recursion
We would like to define a function only writing its /defining equations/.
An example of this is this =double= function

\[\begin{aligned} 
\mathtt{double}(0) &:\equiv 0 \\ 
\mathtt{double}( \mathtt{succ}(n) ) &:\equiv \mathtt{succ} (\mathtt{succ} (\mathtt{double} (n))).
\end{aligned}\]

This style is called *pattern matching*; it is similar to recursion but
it is limited in the recursive calls it can use. Explicitly, it can be used
only as a shorthand for writing a definition using the recursor. Given

\[\begin{aligned} 
f(0) &:\equiv \Phi_0 \\ 
f( \mathtt{succ}(n) ) &:\equiv \Phi_{s},
\end{aligned}\]

we need $\Phi_s$ to depend on $f$ only via $f(n)$ in order to be well-defined as

\[
f :\equiv \mathtt{rec}_{\mathbb{N}} (C,\Phi_0,\lambda n. \lambda r. \Phi'_{s}).
\]

*** I.1.11. Propositions as types
An element of the type corresponding to a proposition is a *witness* or 
a *proof* of the truth of that proposition. From this perspective, proofs
are mathematical objects per se.

# Cite Wadler

**** Falsity and negation

**** Constructive logic
The natural interpretation of propositions-as-types is /constructive/,
meaning that certain tautologies on classical logic, such as the 
*law of excluded middle* (LEM) do not hold.

The logic is still compatible with the presence of the LEM as an axiom.

*** I.1.12. Identity types

\[ \mathtt{refl} : \prod_{a:A} (a =_A a)
\]

** I.2. Homotopy type theory
In homotopy type theory, each type has the structure of an
$\infty\text{-groupoid}$, arising from the induction principle for
identity types.

Homotopy type theory provides a /synthetic/ description of the spaces,
in contrast with the usual analytic approach of topology.

*** TODO 2.1. Types are higher groupoids
*** 2.2. Functions are functors
**** 2.2.1. Definition of ap
Given $f: A \to B$, there is an operation

\[
\ap_f : x=y \to f(x) = f(y)
\]

such that $\ap_f(\refl) \equiv \refl_{f(x)}$.

***** Notation
We write $\ap_f(p)$ as $f(p)$.

***** Proof
Trivially defined by path induction.

**** 2.2.2. Functioriality of ap
Given $f : A \to B$ and $g : B \to C$ and paths $p : x = y$ and
$q : y = z$, we have

 1) $\ap_f(p \cdot q) = \ap_f(p) \cdot \ap_f(q)$
 2) $\ap_f(p^{-1}) = ap_f(p)^{-1}$
 3) $\ap_g(\ap_f(p)) = \ap_{g \circ f}(p)$
 4) $\ap_{id_A}(p) = p$

***** Proof
Trivial by path induction on $p$.

*** 2.3. Type families are fibrations
**** 2.3.1. Transport
Given $P : A \to {\cal U}$ and $p : x = y$, there exists a function

\[
p_{\ast} : P(x) \to P(y),
\]

such that $\refl_{\ast}$ is the identity.

***** Notation
Sometimes we notate transport as

\[
p_{\ast} \equiv \transport^P(p,-) : P(x) \to P(y).
\]

***** Proof
Applying path induction over $p$, $x \equiv y$ and $\id : P(x) \to P(x)$
is an inhabitant of the type.

**** 2.3.2. Path lifting property
Given $P : A \to {\cal U}$ and $u : P(x)$, for any $p : x = y$,

\[
\mathsf{lift}(u,p) : (x,u) = (y, p_{\ast}(u));
\]

in $\sum_{x:A}P(x)$ such that $\mathsf{pr}_1(\mathsf{lift}(u,p)) = p$.

***** Proof
The first component is given by $p$, the second one can be defined
applying path induction over $p$ and, knowing that $x \equiv y$ and thus,
$u \equiv p_{\ast}(u)$.

**** 2.3.4. Dependent map
Given $f : \prod_{x:A} P(x)$ there exists a map

\[
\apd_f : \prod_{p : x=y} p_{\ast}(f(x)) =_{P(y)} f(y)
\]

***** Proof
Path induction.

**** TODO 2.3.5. Constant transport
**** TODO 2.3.8. Constant plus dependent transport
**** 2.3.9. Transport composition lemma
Given $P : A \to {\cal U}$, $p : x = y$ and $q : y = z$, for $u : P(x)$ we have

\[
q_{\ast}(p_{\ast}(u)) = (p \cdot q)_{\ast} (u).
\]

***** Proof
Double path induction.

**** TODO 2.3.10. Transport precomposition lemma
**** TODO 2.3.11. Naturality of transport
*** 2.4. Homotopies and equivalences
**** 2.4.1. Homotopy
A *homotopy* between $f, g : \prod_{x:A} P(x)$ is a dependent function
of type

\[
(f \sim g) :\equiv \prod_{x:A} f(x) = g(x).
\]

**** 2.4.2. Homotopy is an equivalence relation
Homotopy is an equivalence relation on each dependent function
type $\prod_{x:A} P(x)$. We have elements of

 1) reflexivity

    \[
    \prod_{f:\prod_{x:A} P(x)} (f \sim f)
    \]

 2) symmetry

    \[
    \prod_{f,g : \prod_{x:A}P(x)} (f \sim g) \to (g \sim f)
    \]

 3) transitivity

    \[
    \prod_{f,g,h : \prod_{x:A} P(x)} (f \sim g) \to (g \sim h) \to (f \sim h)
    \]

***** Proof
Given any $f$ and $x$, $\refl$ is of type $f(x) = f(x)$.

Given any $f,g$ such that $f \sim g$, for every $x$, we have an inhabitant of
$f \sim g$. By path induction, it must be $\refl$, so $\refl : g(x) = f(x)$.
 
Given any $f,g,h$ such that $f \sim g$ and $g \sim h$, for every $x$, we
have $f(x) = g(x) = h(x)$, and, in particular $f(x) = h(x)$.

**** 2.4.3. Naturality of homotopies
Given $H : f \sim g$ and $p : x = y$, 

\[
H(x) \cdot g(p) = f(p) \cdot H(y).
\]

As a commutative diagram,

\[\begin{tikzcd}
f(x)\rar[equal]{f(p)} \dar[swap,equal]{H(x)} & 
f(y)\dar[equal]{H(y)} \\
g(x)\rar[equal]{g(p)} &
g(y)
\end{tikzcd}\]


***** Proof
By path induction, $p = \refl$, and $\ap$ computes on reflexivity.

**** 2.4.4. Endonaturality of homotopies
Given $H : f \sim \id_{A}$, for any $x : A$,

\[
H(f(x)) = f(H(x))
\]

***** Proof
By naturality, and knowing that $H(x) : f(x) = x$, 

\[\begin{tikzcd}
f(x)\rar[equal]{f(H(x))} \dar[swap,equal]{H(x)} & 
f(f(x))\dar[equal]{H(f(x))} \\
x\rar[equal]{H(x)} &
f(x)
\end{tikzcd}\]

thus,

\[
f(H(x)) \cdot H(x) = H(f(x)) \cdot H(x),
\]

and then $f(H(x)) = H(f(x))$.

**** 2.4.6. Quasi-inverse
A *quasi-inverse* of $f : A \to B$ is a triple $(g,\alpha,\beta)$ with homotopies
$\alpha : f \circ g \sim \id_B$ and $\beta : g \circ f \sim \id_A$.

\[
\mathsf{qinv}(f) = \sum_{g:B \to A} (f \circ g \sim \id) \times (g \circ f \sim \id).
\]

**** 2.4.9. Transport has a quasi-inverse
The transport $p : x = y$ for $P \colon A \to {\cal U}$,

\[
\mathsf{transport}^P(p,-) : P(x) \to P(y)
\]

has a quasiinverse $\transport^P(p^{-1},-)$.

*** 2.5. Higher groupoid structure of type formers

*** 2.6. Cartesian product types
**** 2.6.2. Cartesian product equalities
For any $x,y$, the function

\[
x = y \to (\proj_1(x) = \proj_1(y)) \times (\proj_2(x) = \proj_2(y))
\]

given by applying projections to the equality, is an equivalence.
We denote the quasiinverse as

\[
\mathsf{pair}^{=} :
(\proj_1(x) = \proj_1(y)) \times (\proj_2(x) = \proj_2(y))
\to
x = y.
\]

***** Proof
We will define a function in the other direction. By induction,
we assume $x \equiv (a,b)$ and $y \equiv (a',b')$; thus we have $a = a'$
and $b = b'$. We apply path induction to both paths and we
get that $(a,b) \equiv (a',b')$.

Now we have to prove that it is a quasiinverse. In one direction,
if we have $r : x = y$, we apply path induction and we get the
pair $(\refl_{\proj_1(x)}, \refl_{\proj_2(x)})$. If we apply induction to $x$, we
get $(\refl_a,\refl_{b})$; our inverse takes this to $\refl_{(a,b)}$.

In the other direction, if we have $p : a = a'$ and $q : b = b'$,
we apply induction to get $\refl_{(a,b)}$; applying a function to
reflexivity gives again $(\refl_a, \refl_b)$.

**** 2.6.4. Cartesian product transport
Given two type families $A,B : Z \to {\cal U}$ and a path $p : z = w$,
for every $x : A(z) \times B(z)$,

\[
p_{\ast}(x) = (\transport^A(p,\proj_1(x)), \transport^B(p,\proj_2(x)))
\]

***** Proof
By path induction, it remains to prove

\[
x = (\proj_1(x), \proj_2(x)),
\]

which is definitionally equal.

**** 2.6.5. Functoriality under cartesian products
Given $x,y : A \times B$, $p,q$ path between components. For every function
defined as $f(x) :\equiv (g(\proj_1(x)), h(\proj_2(x)))$, it holds that

\[
f(\mathsf{pair}^{=}(p,q)) = \mathsf{pair}^{ =}(g(p),h(q)).
\]

***** Proof
We first apply induction over $x$, and then path induction over
$p,q$. We get reflexivity in both sides.

*** 2.7. Sigma types
**** 2.7.2. Sigma type equalities
Given a type family $P : A \to {\cal U}$, there is an equivalence

\[
(w = w') \simeq \sum_{p : \proj_1(w) = \proj_1(w')} 
p_{\ast}(\proj_2(w)) = \proj_2(w'). 
\]

This can be seen as an introduction $\pair^{=}$ and elimination rules
for equalities between dependent pairs.

***** Proof
****** First component of the equivalence
We define the first part of the equivalence depending on
$w,w' : \sum_{x:A}P(x)$, of type

\[
f : \prod_{w,w' : \sum_{x:A}P(x)} 
\left(
(w=w') \to
\sum_{p:\proj_1(w) = \proj_1(w')} p_{\ast}(\proj_2(w)) = \proj_2(w')
\right)
\]

by induction on the path $w = w'$ as

\[
f(w,w,\refl) = (\refl_{\pr_1(w)}, \refl_{\pr_2(w)}).
\]

****** Second component of the equivalence
And we define the second part of the equivalence depending
again on both $w,w'$, of type

\[
g : \prod_{w,w' : \sum_{x:A}P(x)}
\left( \left(
\sum_{p:\pr_1(w) = \pr_1(w')}  
p_{\ast}(\pr_2(w)) = \pr_2(w')
\right)
\to (w = w')
\right)
\]

defined by induction on $w = (x,y)$ and $w' = (x',y')$ first and then on
$p : x = x'$ and $p_{\ast}(y) = y'$, to get

\[
g((x,y),(x,y),\refl,\refl) = \refl_{(x,y)}.
\]

****** First homotopy
Finally, we have to show that they form an equivalence. Given any $w,w'$ and

\[
r : \sum_{p:\pr_1(w) = \pr_1(w')} p_{\ast}(\pr_2(w)) = \pr_2(w'),
\]

we can apply induction over both $w = (x,y)$ and $w' = (x',y')$, and then over
$r$ to get paths $p : x = y$ and $p_{\ast}(y) = y'$. By path induction and the definition
of $f$ and $g$, we get the desired result, $f(g(r)) = r$.

****** Second homotopy
On the other hand, if we have $p : w = w'$, we can directly apply path induction
and use the definitions to get $g(f(p)) = p$.

**** 2.7.3. Sigma equality to its parts
For any $z : \sum_{x:A}P(x)$, we have $z = (\pr_1(z),\pr_2(z))$.

***** Proof
By induction on $z = (x,y)$, we trivially arrive at an
identity path.

# HoTT MAILING LIST !

***** Proof in HoTT book
Applying the [[*2.7.2. Sigma type equalities][previous lemma]], we only have to provide evidence
for the equality of both projections. We trivially have

\[
\pr_1(z) = \pr_1(\pr_1(z),\pr_2(z))
\]

and by judgmental equality, it is trivial that

\[
(\refl_{\pr_1(z)})_{\ast}(\pr_2(z)) = \pr_2(z) = \pr_2(\pr_1(z),\pr_2(z)).
\]

**** 2.7.4. Transport over sigma equalities
Given $P : A \to {\cal U}$ and

\[
Q : \left( \sum_{x:A} P(x) \right) \to {\cal U},
\]

for any path $p : x = y$, and $(u,z) : \sum_{u:P(x)} Q(x,u)$ we have

\[
p_{\ast}(u,z) = 
(p_{\ast}(u), \pair^{=}(p,\refl_{p_{\ast}(u)})_{\ast} (z)).
\]

*** 2.8. The unit type
**** Unit type equality
Given $x,y:1$, we have $(x = y) \simeq 1$.

***** Proof
A function $(x = y) \to 1$ is defined trivially; and given any $x, y : 1$
we now by induction that $x \equiv y$ and we can write a constant function
to $\refl_{\star}$.

Given an element $u : 1$, it is trivial that the composite is an element
of $1$, and therefore both are equal to $\star$. Given an element $p : x = y$,
we can apply path induction to get $p = \refl_{x}$ and induction over $x$ to
get $\refl_{\star}$. As a consequence, $p$ goes to $\refl_{\star}$.

*** 2.9. The function extensionality axiom
**** 2.9.2. happly
There exists a function

\[
\happly : (f = g) \to \prod_{x:A} f(x) = g(x)
\]

defined by path induction.

**** 2.9.3. Function extensionality axiom
The function $\happly$ is an equivalence. It has a quasi-inverse given
by

\[
\funext : \left(\prod_{x:A} f(x) = g(x)\right) \to (f = g).
\]

such that, for any $h : \prod_{x:A} f(x) = g(x)$,

\[
\happly(\funext(h), x) = h(x).
\]

**** TODO 2.9.4. Dependent identity, inverses and composition

**** 2.9.4. Rules for dependent transport
Given $f : A(x) \to B(x)$ and $p : x = y$,

\[
p_{\ast}(f) = p_{\ast}\circ f \circ p^{-1}_{\ast}.
\]

***** Proof
Path induction.

**** 2.9.6. Equivalence for the dependent function equality
Given $A,B : X \to {\cal U}$, $p : x = y$ and two functions $f : A(x) \to B(x)$
and $g : A(y) \to B(y)$, we have an equivalence

\[
(p_{\ast}(f) = g) \simeq \prod_{a:A(x)} p_{\ast}(f(a)) = g(p_{\ast}(a)).
\]

Moreover, given $q : p_{\ast}(f) = g$, we have

\[
\happly(q,p_{\ast}(a)) : (p_{\ast}(f))(p_{\ast}(a)) = g(p_{\ast}(a))
\]

equal to the composite

\[
p_{\ast}(f)(p_{\ast}(a)) = p_{\ast}(f(p^{-1}_{\ast}(p_{\ast}(a))))
= p_{\ast}(f(a)) = g(p_{\ast}(a)).
\]

***** Proof
By path induction on $p$, we arrive to function extensionality.
Computation rule for function extensionality gives us the value
of $\happly$.

**** TODO 2.9.7. Transport equivalence between families
*** 2.10. Universes and the univalence axiom
**** 2.10.1. idtoeqv
Given any types $A,B : {\cal U}$, there is a function

\[
\idtoeqv : (A = B) \to (A \simeq B).
\]

***** TODO Proof

**** 2.10.3. Voevodsky's Univalence Axiom
A universe is univalent if for any $A,B : {\cal U}$, $\idtoeqv$ is an equivalence.
All universes are univalent. There exists

\[\ua : (A \simeq B) \to (A = B),
\]

such that 

\[
\transport(\ua(f), x) = f(x).
\]

**** TODO 2.10.5. Transport and idtoeqv
*** 2.11. Identity type
**** 2.11.1. Aplication of equivalences is an equivalence
If $f : A \to B$ is an equivalence, so is

\[
\mathsf{ap}_f : (a = a') \to (f(a) = f(a')).
\]

***** Proof
Let $f^{-1}$ be a quasiinverse with homotopies

\[
\alpha : \prod_{b:B} f(f^{-1}(b)) = b
\quad\mbox{ and }\quad
\beta : \prod_{a:A}f^{-1}(f(a)) = a.
\]

the quasiinverse of $\ap_f$ will be $\ap_{f^{-1}}$ concatenated with $\beta^{-1}$ and $\beta$.
We will show that this is a quasiinverse. On one direction,

\[
\beta_a^{-1} \cdot \ap_{f^{-1}}(\ap_f(p)) \cdot \beta_{a'} = p
\]

is true by [[*2.4.4. Endonaturality of homotopies][endonaturality of the homotopy]] $\beta$ and functoriality
of the application $\ap_{f^{-1}} \circ \ap_f = \ap_{f^{-1} \circ f}$.

**** 2.11.2. Path transport
Given any $a : A$ with $p : x_1 = x_2$,

 1) for $q : a = x_1$, we have $\transport^{x \mapsto a=x}(p,q) = p_{\ast}(q) = q \cdot p$;
 2) for $q : x_1 = a$, we have $\transport^{x\mapsto x=a}(p,q) = p^{-1} \cdot q$;
 3) for $q : x_1 = x_1$, we have $\transport^{x\mapsto (x=x)}(p,q) = p^{-1} \cdot q \cdot p$.

***** Proof
By path induction on $p$, we get the composition rules for
reflexivity.

** I.3. Sets and logic
*** 3.1. Sets and n-types
**** 3.1.1. Sets
A type $A$ is a *set* if every two equalities $p,q : x =_A y$ are equal.

\[
\textsf{isSet}(A) \equiv \prod_{(x,y : A)} \prod_{(p,q : x = y)} p = q.
\]

**** 3.1.6. Dependent product of sets is a set
Given $A$ a set and $B : A \to {\cal U}$ such that $B(x)$ is a set, $\prod_{x:A} B(x)$ is
a set.

***** Proof
Suppose $f, g : \prod_{x:A} B(x)$ and $p, q : f = g$. Applying function
extensionality,

 * $p = \mathsf{funext}(\lambda x. \mathsf{happly}(p,x))$
 * $q = \mathsf{funext}(\lambda x. \mathsf{happly}(q,x))$

Since $B(x)$ is a set, 

 * $\mathsf{happly}(p,x) : f(x) = g(x)$
 * $\mathsf{happly}(q,x) : f(x) = g(x)$

must be equal. Thus, by function extensionality $(\lambda x. \mathsf{happly}(p,x)) = (\lambda x. \mathsf{happly}(q,x))$,
and applying $\mathsf{funext}$, $p = q$.

**** 3.1.7. 1-types
A type $A$ is a *1-type* if for all $x,y:A$ and $p,q : x = y$ and $r,s : p = q$,
we have $r = s$.

**** 3.1.8. Every set is a 1-type
Every set is a *1-type*.

***** Proof
If we have $x,y : A$, $p,q : x = y$ and $f : \isSet(A)$, then we
can define $g = f(x,y,p)$ by partial application, and

\[
g : \prod_{q : x = y}(p = q);
\]

we can now, given $r : q = q'$, use dependent application to get

\[
\apd_g(r) : r_{\ast}(g(q)) = g(q').
\]

By path transport, that means that $g(q) \cdot r = g(q')$. In particular,
given any two $r,s : p = q$;

\[
g(p) \cdot r = g(q) = g(p) \cdot s
\]

and $r = s$ by cancellation.

**** 3.1.9. Not all types are sets
The universe ${\cal U}$ is not a set.

***** Proof
We take $2$ to be the type of the booleans. There exists a
function $\mathrm{not}\colon 2 \to 2$ which is an equivalence; by univalence,
there exists $\ua(\mathrm{not}) \colon 2 = 2$ which is not $\refl$. If it were
$\refl$, then, by univalence, $0_2 = 1_2$.

*** 3.2. Propositions as types?
**** 3.2.2. Negation of double negation
It is not true that $\neg(\neg A) \to A$ for each $A : {\cal U}$.

***** Proof
Given $f \colon \prod_{A:{\cal U}} \neg(\neg A) \to A$, we will arrive to a contradiction.

Let $p \colon 2 = 2$ be the non-trivial path of the booleans. We know
that $f(2) : \neg\neg 2 \to 2$ and

\[
\apd_f(p) : p_{\ast}(f(2)) = f(2),
\]

applying [[*2.9.4. Rules for dependent transport][rules for dependent transport]], we have

\[
p_{\ast}(f(2))(u) = (p_{\ast} \circ f(2) \circ p_{\ast}^{-1})(u).
\]

Every two $u,v : \neg\neg 2$ are equal by function extensionality; thus

\[
p^{-1}_{\ast}(u) = u
\]

and so

\[
p_{\ast}(f(2)(u)) = p_{\ast}(f(2))(u) = f(2)(u).
\]

We have now that $\fnot(f(2)(u)) = f(2)(u)$, and, at the same time,
it is obvious that $\prod_{x:2} \neg (\fnot(x) = x)$.

**** 3.2.7. Negation of LEM
It is not true that $A + (\neg A)$ for each $A \colon {\cal U}$.

***** Proof
An element of type $\prod_{A:{\cal U}} \neg\neg A \to A$ can be constructed from
an element of type $\prod_{A:{\cal U}} A + (\neg A)$.

*** 3.3. Mere propositions
**** 3.3.1. Mere proposition
A type $P$ is a *mere proposition* when

\[
\isProp(P) : 
\prod_{x,y : P} x = y
\]

is inhabited.

**** 3.3.2. Truth is the only true mere proposition
If $P$ is a mere proposition and $x_0 : P$, then $P \simeq 1$.

***** Proof
A trivial equivalence can be constructed.

**** 3.3.3. Equivalence of connected mere propositions
If $P$ and $Q$ are mere propositions, $P \to Q$ and $Q \to P$
imply $P \simeq Q$.

***** Proof
If $f : P \to Q$ and $g : Q \to P$, then $f(g(x)) = x$ and
$g(f(x)) = x$ because both are mere propositions.

**** 3.3.4. Mere propositions are sets
Every mere proposition is a set.

***** Proof
Given $f : \isProp(A)$, we fix $x : A$ and define $g(y) :\equiv f(x,y)$
of type $\prod_{y : A} x = y$. Given two $y,z : A$ with $p : y = z$, we
have

\[
\apd_g(p) : p_{\ast}(g(y)) = g(z)
\]

hence $g(y) \cdot p = g(z)$, or $p = g(y)^{-1} \cdot g(z)$; thus given $p,q : x = y$
we have $p = g(x)^{-1} \cdot g(y) = q$.

**** 3.3.5. isProp and isSet are mere propositions
Given any type $A$, the types $\isSet(A)$ and $\isProp(A)$ are mere
propositions.

***** Proof
If we have $f,g : \isProp(A)$ we know that $f(x,y) = g(x,y)$ because
$A$ is a mere proposition. By function extensionality, $f = g$.

If we have $f,g : \isSet(A)$ we know that $f(x,y,p,q) = g(x,y,p,q)$
because $x = y$ is a mere proposition from the fact that $A$ is a set.
By function extensionality, $f = g$.

*** 3.4. Classical vs. intuitionistic logic
**** 3.4.1. Law of excluded middle
We define the *law of excluded middle* as

\[
\LEM :\equiv \prod_{A : {\cal U}} \Big( \isProp(A) \to (A + \neg A) \Big)
\]

whereas the usual general law of excluded middle is renamed as

\[
\LEM_{\infty} :\equiv \prod_{A : {\cal U}} (A + \neg A).
\]

The law of excluded middle can be assumed as an axiom.

**** 3.4.3. Decidable types
1. A type is *decidable* if $A + \neg A$.

2. A type family is *decidable* if

   \[
   \prod_{a : A} B(a) + \neg B(a)
   \]

3. A type has *decidable equality* if
   
   \[
   \prod_{a,b : A} (a = b) + \neg (a = b)
   \]

The Law of excluded middle says that all mere propositions are
decidable.

*** 3.5. Subsets and propositional resizing
**** 3.5.1. Uniqueness of dependent sum of mere propositions
Given $P \colon A \to {\cal U}$ such that $P(a)$ is always a mere proposition;
if $u,v \colon \sum_{x:A}P(x)$ are such that $\proj_1(u) = \proj_1(v)$, then
$u = v$.

***** Proof
Given $p : \proj_1(u) = \proj_1(v)$, we only have to show that

\[
p_{\ast}(\proj_2(u)) = \proj_2(v)
\]

and this is true because both are members of $P(\proj_1(v))$, a
mere proposition.

**** 3.5.1. Subtypes
If $P$ is a family of mere propositions, we write

\[
\sum_{x:A} P(x) \equiv \left\{ x : A\mid P(x) \right\}
\]

and call this a *subtype*. We can define membership and subsets
analogously.

***** Subuniverses of sets and mere propositions
We define

 * $\Set_{{\cal U}} :\equiv \left\{ A : {\cal U} \mid \isSet(A) \right\}$,
 * $\Prop_{{\cal U}} :\equiv \left\{ A : {\cal U} \mid \isProp(A) \right\}$.

There are natural maps $\Set_{{\cal U}_i} \to \Set_{{\cal U}_{i+1}}$.

**** 3.5.2. Propositional resizing
*Propositional resizing* is the fact that the natural map
$\Prop_{{\cal U}_i} \to \Prop_{{\cal U}_{i+1}}$ is an equivalence.

Propositional resizing can be taken as an axiom.

***** Omega-indexation of propositions
From propositional resizing follows the existence of $\Omega$, a
type that indexes mere propositions. If propositional resizing
is true, $\Omega :\equiv \Prop_{{\cal U}_0}$.

***** Powersets
If propositional resizing is true, we can define

\[
{\cal P}(A) :\equiv (A \to \Omega),
\]

which is independent of the universe.
*** 3.6. Logic of mere propositions
**** TODO 3.6.1. Product of mere propositions is a mere proposition
**** TODO 3.6.2. Dependent functions to mere propositions are mere propositions
**** TODO 3.6.2. Sums of mere propositions are not mere propositions
*** 3.7. Propositional truncation
**** 3.7.0. Propositional truncation type
For any $A$ there is a *truncation type* $\trunc{A}$, with constructors

 * $|a| : \trunc{A}$ for any $a : A$;
 * $x=y$ for any $x,y : \trunc{A}$;

ensuring that it is a mere proposition.

***** Recursion principle
If $B$ is a mere proposition and $f : A \to B$, then there exists
$g : \trunc{A} \to B$ such that $g(|a|) \equiv f(a)$ for all $a:A$.

**** 3.7.1. Traditional logical notation
We define

 * $\top :\equiv 1$,

 * $\bot :\equiv 0$,

 * $P \land Q :\equiv P \times Q$,

 * $P \lor Q :\equiv \trunc{P + Q}$,

 * $P \Rightarrow Q :\equiv P \to Q$,

 * $P \Leftrightarrow Q :\equiv P = Q$,

 * $\neg P :\equiv P \to 0$,

 * $\forall (x:A). P(x) :\equiv \prod_{x:A} P(x)$,

 * $\exists (x:A).P(x) :\equiv \trunc{\sum_{x:A} P(x)}$.

**** 3.7.2. Traditional set notation
We define

 * $\left\{ x:A\mid P(x) \right\} \cap \left\{ x:A \mid Q(x) \right\} :\equiv \left\{ x:A \mid P(x) \wedge Q(x) \right\}$,
 * $\left\{ x:A \mid P(x) \right\} \cup \left\{ x:A \mid Q(x) \right\} :\equiv \left\{ x:A\mid P(x) \lor Q(x) \right\}$,
 * $A \setminus \left\{ x:A\mid P(x) \right\} :\equiv \left\{ x:A \mid \neg P(x) \right\}$.

Note how the latter are not complements in the absence of LEM.
*** 3.8. The axiom of choice
**** 3.8.1. The axiom of choice
Given a $X$ and type families $A : X \to {\cal U}$, $P : \prod_{x:X} (A(x) \to {\cal U})$
such that $X$ and $A(x)$ are always sets and $P(x,a)$ is always a
mere proposition; the *axiom of choice* asserts

\[
\left( \prod_{x:X} \trunc{\sum_{a:A(x)} P(x,a)} \right)
\to
\trunc{\sum_{(g: \prod_{x:X}A(x))} \prod_{(x:X)} P(x,g(x))}.
\]

In logical notation, this means,

\[
\bigg( \forall (x:X). \exists (a:A(x)). P(x,a) \bigg)
\Rightarrow
\left( \exists \bigg(g: \prod_{x:X}A(x)\bigg). \forall (x:X). P(x,g(x)) \right)
\]
**** 3.8.2. Simpler axiom of choice
The axiom of choice is equivalent to 

\[
\left( \prod_{x:X} \trunc{Y(x)} \right) \to
\trunc{ \prod_{x:X} Y(x) }
\]

for any $X$ and $Y(x)$ always sets.

***** TODO Proof

**** TODO 3.8.5. Counterexample to the simpler version

*** 3.9. The principle of unique choice
**** 3.9.1. Equivalence of mere propositions and truncations
If $P$ is a mere proposition, $P \simeq \trunc{P}$.

***** Proof
We apply the universal property to $\id$ to get $\trunc{P} \to P$;
and we have a $P \to \trunc{P}$ by definition. This [[*3.3.3. Equivalence of connected mere propositions][proves]] an
equivalence of mere propositions.

**** 3.9.2. The principle of unique choice
Given $P \colon A \to {\cal U}$ such that

 * $P(x)$ is always a mere proposition;
 * $\trunc{P(x)}$ is always true.

Then $\prod_{x:A}P(x)$.

***** TODO Proof

*** 3.10. When are propositions truncated?
*** 3.11. Contractibility
**** 3.11.1. Contractible type
A type $A$ is *contractible*, or *singleton* if there is a center of
contraction $a : A$ such that $a = x$ for all $x : A$.

\[
\isContr(A) :\equiv \sum_{a:A}\prod_{x:A}(a = x)
\]

**** 3.11.3. Characterization of contractibility
Given $A$, the following are equivalent

 1. $A$ is contractible,
 2. $A$ is a mere proposition, and there is a point $a:A$,
 3. $A$ is equivalent to $1$.

***** Proof
If $A$ is contractible, it has a point $a : A$ and every two other
points are equal to it.

If $A$ is an inhabited mere proposition, it is equivalent to $1$.

And $1$ is contractible.

**** TODO 3.11.4. Contr is a mere proposition
**** TODO 3.11.5. Contractibility of Contr
**** TODO 3.11.6. Dependent product of contractible types
**** TODO 3.11.7. Retracts and contractibility
**** TODO 3.11.8.
**** TODO 3.11.9.
**** 3.11.10. Mere propositions and contractibility
$A$ is a mere proposition iff for all $x,y : A$, the type $x = y$ is
contractible.

***** TODO Proof
If $A$ is a mere proposition, then $x = y$ must be true; it must be
also a set, so $x=y$ must be contractible.

If $x=y$ is contractible, it is inhabited, so $A$ is a mere
proposition.

** I.4. Equivalences
*** 4.1. Quasi-inverses
**** 4.1.1. Characterization of the quasi-inverse type
If given $f : A \to B$, $\qinv{}(f)$ is inhabited,

\[
\qinv(f) \simeq \prod_{x:A}(x=x)
\]

***** TODO Proof
As $f$ is an equivalence, we apply univalence to get $p : A = B$.
Applying path induction, $p = \refl$ and $f = \id$. Then,

\[
\qinv(\id) \equiv \sum_{g : A \to A} (g \sim \id) \times (\id \sim g)
\]

which is equivalent by function extensionality to

\[
\sum_{g : A \to A} (g = \id) \times (g = \id)
\]

**** 4.1.2. Existence of center
Given $a : A$ and $q : a = a$ such that

 1. $a = a$ is a set,
 2. $\trunc{a = x}$ for all $x : A$,
 3. $p \cdot q = q \cdot p$ for all $p : a = a$,

there exists $f : \prod_{x:A}(x = x)$ such that $f(a) = q$.

***** TODO Proof
**** 4.1.3. qinv is not always a mere proposition
There exists a function such that $\qinv(f)$ is not a mere
proposition.

***** TODO Proof
*** TODO 4.2. Half adjoint equivalences
**** 4.2.1. Half adjoint equivalence
A function $f : A \to B$ is a *half adjoint equivalence* if

\[
\ishae(f) :\equiv
\sum_{(g : B \to A)}
\sum_{(\eta : g \circ f \sim \id_{A})}
\sum_{(\epsilon : f \circ g \sim \id_{B})}
\prod_{(x:A)}
f(\eta(x)) = \epsilon(f(x))
\]

that is, there exist two homotopies and a coherence condition
between them.

**** 4.2.2. Logical equivalence of half adjoint equivalences
Given $f : A \to B$ and $g : B \to A$ with homotopies $\eta : g \circ f \sim \id$ and
$\epsilon : f \circ g \sim \id$, the following two types are logically equivalent

 * $\prod_{x:A}f(\eta(x)) = \epsilon(f(x))$,

 * $\prod_{x:A} g(\epsilon(x)) = \eta(g(x))$.

***** Proof
We will prove the second homotopy from $\tau : \prod_{x:A}f(\eta(x)) = \epsilon(f(x))$;
simmetry gives us the other direction.

By [[*2.4.4. Endonaturality of homotopies][endonaturality of homotopies]] in $\epsilon$ we have

\[\begin{tikzcd}
fgfg(x) \rar[equal]{fg \epsilon(x)} \dar[swap,equal]{\epsilon fg(x)} & 
fg(x) \dar[equal]{\epsilon(x)} \\
fg(x) \rar[equal]{\epsilon(x)} &
x
\end{tikzcd}\]

and applying $g$ to the complete diagram renders

\[\begin{tikzcd}
gfgfg(x) \rar[equal]{gfg\epsilon(x)} \dar[swap,equal]{g\epsilon fg(x)} & 
gfg(x) \dar[equal]{g\epsilon(x)} \\
gfg(x) \rar[equal]{g\epsilon(x)} &
gx
\end{tikzcd}\]

applying now the homotopy $\tau(g(x))$, we get $g \epsilon fg(x) = gf \eta g(x)$;
and again by [[*2.4.4. Endonaturality of homotopies][naturality]], we have $gf \eta g(x) = \eta gfg(x)$, and the
diagram is

\[\begin{tikzcd}
gfgfg(x) \rar[equal]{g fg\epsilon(x)} 
\dar[swap,equal]{\eta gfg(x)} & 
gfg(x) \dar[equal]{g\epsilon(x)} \\
gfg(x) \rar[equal]{g\epsilon(x)} &
gx
\end{tikzcd}\]

Meanwhile, by naturality of $\eta$ between $gfgfg$ and $gfg$, we have that

\[\begin{tikzcd}
gfgfg(x) \rar[equal]{g fg\epsilon(x)} 
\dar[swap,equal]{\eta gfg(x)} & 
gfg(x) \dar[equal]{\eta g(x)} \\
gfg(x) \rar[equal]{g\epsilon(x)} &
gx
\end{tikzcd}\]

and joining both diagrams we get $\eta g(x) = g \epsilon(x)$.

**** 4.2.3. qinv implies ishae
It is obvious that $\ishae$ implies $\qinv$.
For any $f : A \to B$ we have $\qinv(f) \to \ishae(f)$.

***** Proof
Given a quasiinverse $(f,g,\eta,\epsilon)$, we will define a new tuple
$(f,g,\eta,\epsilon',\tau')$; taking $\epsilon'$ to be

\[
\epsilon'(b) :\equiv \epsilon fg(b)^{-1} \cdot f\eta g(b) \cdot \epsilon(b)
\]

so we need to find an homotopy

\[
\tau(a) : f\eta(a) = \epsilon fgf(a)^{-1} \cdot f \eta gf(a) \cdot \epsilon f(a)
\]

but we know by [[*2.4.4. Endonaturality of homotopies][endonaturality]] that $\eta gf(a) = gf \eta(a)$ and by
homotopy that

\[
f \eta gf(a) \cdot \epsilon f(a) = fgf\eta(a) \cdot \epsilon f(a) = \epsilon fgf(a) \cdot f\eta(a).
\]

**** 4.2.4. Fiber of a map
The *fiber* of $f : A \to B$ over a point is

\[
\fib_f(y) :\equiv \sum_{x:A}(f(x) = y).
\]

**** 4.2.5. Equality of fibers
Given $f : A \to B$ and $(x,p), (x',p') : \fib_f(y)$,

\[
((x,p) = (x',p'))
\simeq
\left( \sum_{\gamma : x = x'} f(\gamma) \cdot p' = p \right)
\]

***** TODO Proof
# Path lemmas

**** 4.2.6. Fibers of half-adjoint equivalences are contractible
If $\ishae(f)$ for $f : A \to B$, then $\fib_f(y)$ is contractible for any $y : B$.

***** TODO Proof

**** 4.2.7. Left and right inverses
Given $f : A \to B$ we define

 * its *left inverses*, $\linv(f) :\equiv \sum_{g : B \to A} (g \circ f \sim \id)$,

 * its *right inverses*, $\rinv(f) :\equiv \sum_{g \colon B \to A}(f \circ g \sim \id)$.

*** TODO 4.3. Bi-invertible maps
**** 4.3.1. Bi-invertible
A function $f : A \to B$ is *bi-invertible* if it
[[*4.2.7. Left and right inverses][has left and right inverses]]

\[
\biinv(f) :\equiv \linv(f) \times \rinv(f).
\]

**** 4.3.2. biinv is a mere proposition
The type $\biinv(f)$ is a mere proposition for any $f : A \to B$.

***** TODO Proof

**** 4.3.3. Equivalence biinv and ishae
Given $f : A \to B$, we have $\qinv(f) \simeq \ishae(f)$.

***** TODO Proof
*** TODO 4.4. Contractible fibers
**** 4.4.1. Contractible maps
A function $f : A \to B$ is *contractible* if $\fib_f(y)$ is contractible
for every $y : B$; that is, we define

\[
\isContr(f) :\equiv \prod_{y:B} \isContr(\fib_f(y)).
\]

**** 4.4.3. isContr implies ishae
For any $f : A \to B$, we have $\isContr(f) \to \ishae(f)$.

***** TODO Proof

**** 4.4.4. isContr is a mere proposition
For any $f$, the type $\isContr(f)$ is a mere proposition.

***** TODO Proof
**** 4.4.5. isContr is equivalent to ishae
For any $f : A \to B$, we have $\isContr(f) \simeq \ishae(f)$.

***** TODO Proof
*** 4.5. On the definition of equivalences
We have proved equivalent

\[
\isContr(f) \simeq \ishae(f) \simeq \biinv(f)
\]

so we choose $\isequiv{}(f) :\equiv \ishae(f)$.

*** TODO 4.6. Surjections and embeddings
**** 4.6.0. Isomorphisms
When two sets are equivalent, we say that they is an *isomorphism*
or a *bijection*.

**** 4.6.1. Surjections and embeddings
A function $f : A \to B$ is

 * *surjective* if $\trunc{\fib_f(b)}$ for every $b : B$;
 * *embedding* if $\ap_f : (x=y) \to (f(x) = f(y))$ is an equivalence.

***** Split surjection
We say that a function $f : A \to B$ is a *split surjection* if

\[
\prod_{b:B}\sum_{a:A} f(a) = b.
\]

Note that it is a stronger assertion than being surjective, that
only asks for an inhabitant without constructive evidence.

***** Axiom of choice and split surjections
The [[*3.8.1. The axiom of choice][axiom of choice]] says exactly that every surjection between sets is
split.

**** 4.6.2. Characterization of embeddings
A function $f : A \to B$ between sets is an embedding if and only if

\[
\prod_{x,y:A} f(x) = f(y) \to x = y.
\]

And we say that it is an *injection*.

***** Proof
We apply that $f(x) = f(y)$ and $x = y$ are mere propositions to get
an equivalence from the logical implications.

**** 4.6.3. Equivalence is surjection and embedding
Any function $f : A \to B$ is an equivalence if and only if it is both
surjective and an embedding.

***** TODO Proof

**** 4.6.4. Equivalence is equivalent to surjection and embedding
For any $f : A \to B$,

\[
\isequiv(f) \simeq \isEmbedding(f) \times \isSurjective(f).
\]

*** TODO 4.7. Closure properties of equivalences
**** 4.7.1. The 2-out-of-3 property
If any two $f,g,g\circ f$ are equivalences, so is the third.

***** TODO Proof

**** TODO 4.7.2. Retracts

*** TODO 4.8. The object classifier
**** TODO 4.8.1. Fiber of a type family

*** 4.9. Univalence implies function extensionality
We do not assume function extensionality on this section.

**** 4.9.1. Weak function extensionality principle
The *weak function extensionality principle* asserts that,
for any family $P : A \to {\cal U}$,

\[
\left( \prod_{x:A} \isContr(P(x)) \right)
\to
\isContr \left( \prod_{x:A}P(x) \right).
\]

**** 4.9.2. Equivalence on slice objects
If ${\cal U}$ is univalent, $A,B,X : {\cal U}$ and $e : A \simeq B$, there is 
an equivalence

\[
(X \to A) \simeq (X \to B).
\]

***** TODO Proof

**** TODO 4.9.3. 

**** TODO 4.9.5. Weak function extensionality implies function extensionality
The weak function extensionality principle implies the axiom
of [[*2.9.3. Function extensionality axiom][function extensionality]].

***** Proof

** I.5. Induction
*** 5.1. Introduction to inductive types
**** 5.1.1. Uniqueness of functions over the natural numbers
Given $f,g : \prod_{n:\mathbb{N}} E(x)$ with

\[
e_z : E(0)
\quad\text{ and }\quad 
e_s : \prod_{n:\mathbb{N}}E(n) \to E(\succ(n)) 
\]

such that $f(0) = e_z = g(0)$ and

 * $\prod_{n:\mathbb{N}} f(\succ(n)) = e_s(n,f(n))$,
 * $\prod_{n:\mathbb{N}} g(\succ(n)) = e_s(n,g(n))$;

then $f$ and $g$ are equal.

***** Proof
We apply induction on $n$ over the type family $f(n) = g(n)$.
In the base case, $f(0) = g(0)$; and in the successor case,
knowing that $f(n) = g(n)$,

\[
f(\succ(n)) = e_s(n,f(n)) = e_s(n,g(n)) = g(\succ(n)).
\]

**** TODO 5.2. Uniqueness of inductive types
*** TODO 5.3. W-types
*** 5.4. Inductive types are initial algebras
**** 5.4.1. N-algebra
A $\mathbb{N}\text{-algebra}$ is a type with two elements

\[
\mathbb{N}\text{alg} :\equiv \sum_{C:{\cal U}} C \times (C \to C).
\]

**** 5.4.2. N-homomorphism
A $\mathbb{N}\text{-homomorphism}$ between algebras is a function preserving
the zero and successor elements up to path equality

\[
\mathbb{N}\text{Hom}((C,c_0,c_s), (D,d_0,d_s)) :\equiv
\sum_{h \colon C \to D} (h(c_0) = d_0) \times \left( \prod_{c:C} h(c_s(c)) = d_s(h(c)) \right).
\]

**** 5.4.3. Homotopy initial N-algebra
An algebra is homotopy initial if the type of homomorphisms to any
other algebras is contractible; that is

\[
\isHinit_{\mathbb{N}}(I) :\equiv \prod_{C : \mathbb{N}\text{Alg}} \isContr(\mathbb{N}\text{Hom}(I,C)).
\]

**** TODO 5.4.4. Uniqueness of homotopy initial N-algebras

**** TODO 5.4.5. The naturals are an homotopy initial N-algebra
**** TODO 5.4.6. W-algebras
*** TODO 5.5. Homotopy-inductive types
** I.6. Higher inductive types
*** 6.2. Induction principles and dependent paths
**** 6.2.1. Propositional equality by definition
In the case of higher inductive types, we give equalities by
definition that use non-fundamental parts of the type theory,
and so they are propositional instead of judgmental.

We write them as $f(\loop) := \ell$ to indicate this fact.

**** 6.2.2. Notation for dependent paths
We write dependent paths as

\[
(u =^P_p v) :\equiv \transport^P(p,u) = v.
\]

**** 6.2.5. Non-dependent computation rule of the circle
Given $a : A$ with $p : a = a$, there is a function $f : \mathbb{S}^1 \to A$ such
that

 * $f(\base) :\equiv a$,
 * $\ap_f(\loop) :\equiv p$.

***** TODO Proof

*** 6.5. Suspensions
**** 6.5.0. Suspension of a type
The *suspension* of a type $A$ is a type $\Sigma A$ defined by the
generators

 * north, $\N : \Sigma A$;

 * south, $S : \Sigma A$;

 * and meridians, $\merid : A \to (\N = \S)$.

***** TODO Induction principle

**** 6.5.1. Circle as suspension
The circle can be seen as the suspension of the booleans,

\[
\Sigma 2 \simeq \mathbb{S}^{1}.
\]

***** TODO Proof

*** TODO 6.6. Cell complexes

*** TODO 6.7. Hubs and spokes
** I.7. Homotopy n-types
*** 7.1. Definition of n-types
**** 7.1.1. is-n-type
We define $\istype{n} : {\cal U} \to {\cal U}$ as

\[
\istype{n}(X) :\equiv
\left\{\begin{array}{ll}
\isContr(X) & \mbox{if } n = -2, \\
\prod_{x,y:X} \istype{n'}(x = y) & \mbox{if } n = n' + 1.
\end{array}\right.
\]

**** TODO 7.1.4. Retraction of an n-type
**** TODO 7.1.5. Equivalence preserves n-types
*** 7.2. Uniqueness of identity proofs and Hedberg's theorem
**** TODO 7.2.0. Uniqueness of identity proofs (UIP)

**** 7.2.1. Axiom K
A type $A$ is a set if and only if it satisfies *Axiom K*, for
all $x:X$ and $p : x = x$, we have $p = \refl$.

***** TODO Proof

**** 7.2.2. Mere identity relations in sets
Given $R$ a reflexive mere relation on $X$ implying identity, $X$
is a set and $R(x,y) \simeq (x = y)$ for all $x,y :X$.

***** Proof
Given $\rho : \prod_{x:X}R(x,x)$ and $f : \prod_{x,y}R(x,y) \to (x = y)$, we have
that if $X$ is a set, $x = y$ is a mere proposition logically equivalent
to $R(x,y)$. On the other hand, if $x = y$ is equivalent to $R(x,y)$ and
it is a mere proposition, $X$ is a set.

We can give two proofs, either proving that $X$ is a set or that $R(x,y)$
is equivalent to $x = y$.

****** X is a set
Given $x:X$ and $p : x = x$, we consider

\[
\apd_{f(x)}(p) : p_{\ast}(f(x,x)) = f(x,x)
\]

which, by [[*2.9.6. Equivalence for the dependent function equality][path equalities for dependent functions]] gives us a path

\[
p_{\ast}(f(x,x,r)) = f(x,x,p_{\ast}(r)).
\]

Knowing that $R(x,x)$ is a mere proposition, $p_{\ast}(r) = r$; and transport
in the identity type is equal to concatenation, so

\[
f(x,x,r) \cdot p = f(x,x,r)
\]

and $p = \refl$, satisfying axiom K.

****** TODO R is equivalent to equality

**** 7.2.3. A type with double negation cancellation equality is a set
If $X$ has the property $\neg\neg (x=y) \to (x=y)$, it is a set.

***** Proof
We have $\neg\neg(x=y)$ as a reflexive mere relation implying identity,
so we can apply the previous [[*7.2.2. Mere identity relations in sets][lemma]].

**** 7.2.5. Hedberg's theorem
If a type has [[*3.4.3. Decidable types][decidable]] equality, it is a set.

***** TODO Proof.

**** 7.2.6. Natural numbers form a set
The type of natural numbers has decidable equality, and hence is a set.

***** TODO Proof

* Part II
** II.8. Homotopy theory
** II.9. Category theory
** II.10. Set theory
** II.11. Real numbers
* Exercises [0/1]
** 1. Exercises: Type theory
*** Exercise 1.1
** 2. Exercises: Homotopy type theory [1/1]
*** DONE Exercise 2.10
#+begin_statement
Prove that \Sigma-types are associative, in that for any $A : {\cal U}$ and
families $B : A \to {\cal U}$ and $C : \left(\sum_{x:A} B(x)\right) \to {\cal U}$, we have

\[
\left( \sum_{x:A}\sum_{y:B(x)} C(x,y) \right)
\simeq
\left( \sum_{p : \sum_{x:A}B(x)} C(p) \right)
\]
#+end_statement

We first define a function

\[
f : \left( \sum_{x:A}\sum_{y:B(x)} C(x,y) \right)
\to
\left( \sum_{p : \sum_{x:A}B(x)} C(p) \right)
\]

by induction on the argument, as

\[
f (x,y,c) :\equiv ((x,y),c).
\]

Now we have to prove that this is an equivalence with two homotopies,
with an inverse defined by induction

\[
g((x,y),c) :\equiv (x,y,c).
\]

In fact, given any $(x,y,c)$, or any $((x,y),c)$ it is trivial to check
that there exist two homotopies. Note how we use induction to get the
constructors of the pair.

** 4. Exercises: Equivalences

