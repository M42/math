#+TITLE: Homotopy type theory
#+DESCRIPTION: Homotopy type theory book

#+SETUPFILE: config.setup
#+SETUPFILE: essay.setup
#+LANGUAGE: en
#+OPTIONS: toc:t todo:nil
#+TODO: TODO WIP | DONE

* Macros                                                             :ignore:
#+latex_header: \newcommand\ap{\mathsf{ap}}
#+latex_header: \newcommand\apd{\mathsf{apd}}
#+latex_header: \newcommand\refl{\mathsf{refl}}
#+latex_header: \newcommand\id{\mathsf{id}}
#+latex_header: \newcommand\transport{\mathsf{transport}}
#+latex_header: \newcommand\happly{\mathsf{happly}}
#+latex_header: \newcommand\funext{\mathsf{funext}}
#+latex_header: \newcommand\proj{\mathsf{pr}}
#+latex_header: \newcommand\rec{\mathsf{rec}}
#+latex_header: \newcommand\pr{\mathsf{pr}}
#+latex_header: \newcommand\idtoeqv{\mathsf{idtoeqv}}
#+latex_header: \newcommand\ua{\mathsf{ua}}
#+latex_header: \newcommand\isSet{\mathsf{isSet}}
#+latex_header: \newcommand\isProp{\mathsf{isProp}}
#+latex_header: \newcommand\Set{\mathsf{Set}}
#+latex_header: \newcommand\Prop{\mathsf{Prop}}
#+latex_header: \newcommand\fnot{\mathsf{not}}
#+latex_header: \newcommand\LEM{\mathsf{LEM}}
#+latex_header: \newcommand\trunc[1]{\left\lVert#1\right\rVert}
#+latex_header: \newcommand\isContr{\mathsf{isContr}}
#+latex_header: \newcommand\ishae{\mathsf{ishae}}
#+latex_header: \newcommand\qinv{\mathsf{qinv}}
#+latex_header: \newcommand\fib{\mathsf{fib}}
#+latex_header: \newcommand\biinv{\mathsf{biinv}}
#+latex_header: \newcommand\linv{\mathsf{linv}}
#+latex_header: \newcommand\rinv{\mathsf{rinv}}
#+latex_header: \renewcommand\succ{\mathsf{succ}}
#+latex_header: \newcommand\isequiv{\mathsf{isequiv}}
#+latex_header: \newcommand\isHinit{\mathsf{isHinit}}
#+latex_header: \newcommand\isEmbedding{\mathsf{isEmbedding}}
#+latex_header: \newcommand\isSurjective{\mathsf{isSurjective}}
#+latex_header: \newcommand\pair{\mathsf{pair}}
#+latex_header: \newcommand\inl{\mathsf{inl}}
#+latex_header: \newcommand\inr{\mathsf{inr}}
#+latex_header: \newcommand\seg{\mathsf{seg}}
#+latex_header: \newcommand\base{\mathsf{base}}
#+latex_header: \newcommand\N{\mathsf{N}}
#+latex_header: \newcommand\conn{\mathsf{conn}}
#+latex_header: \newcommand\code{\mathsf{code}}
#+latex_header: \newcommand\encode{\mathsf{encode}}
#+latex_header: \newcommand\decode{\mathsf{decode}}
#+latex_header: \renewcommand\S{\mathsf{S}}
#+latex_header: \newcommand\merid{\mathsf{merid}}
#+latex_header: \newcommand\istype[1]{\mathop{\mbox{$\mathsf{is}$-$#1$-$\mathsf{type}$}}}

* Part I
** I.1. Type theory
*** I.1.1. Type theory versus set theory
**** Judgements and rules
Set theory is not only about seta but also about the interplay between /sets/
and /propositions/ of first-order logic, the system where sets are formulated.
In contrast, type theory does not need to be formulated inside any 
superstructure such as first-order logic. It is its own deductive system.

First-order logic is based on only one kind of judgment: whether any
given proposition as a proof; but in type theory, the basic judgment
is $a : A$, where $a$ is an element of the type $A$. Although it could
be seen as an analogous to $a \in A$ in set theory, the difference
resides in that $a \colon A$ is not a proposition but a judgment of
the theory. In particular, we cannot disprove those judgements and we
cannot talk about an element $a$ without specifying its type.

**** Propositional equality
Equality here is not a proposition but a type. Given $a,b : A$, we can define
the type $a =_A b$; we say that $a$ and $b$ are *propositionally equal* when this
type is unhabited.

**** Judgmental equality
*Judgmental equality* or *definitional equality* is an equality judgment
given by definitions: it can be decided expanding out the definitions. 
We write it as $a \equiv b$ and we introduce definitions as $a :\equiv b$.

**** Judgments of type theory
Type theory will be a system based on two forms of judgement

 * $a : A$, meaning $a$ has type $A$.
 * $a \equiv b : A$, meaning that $a$ and $b$ are definitionally equal.

**** Contexts
A *context* is a collection of assumptions in which a judgment may depend on.

# It can be thougt as a parameter space (?)
# https://en.wikipedia.org/wiki/Parameter_space

**** Rules and axioms of type theory
Rules of type theory can be grouped into type formers, procedural ways
to construct types. Usually, no axioms are necessary in type theory.

*** I.1.2. Function types
**** Functions
Given types $A,B$, $A \to B$ is the type of *maps* or *functions* between them.
Functions are a primitive concept of type theory; given $f : A \to B$, it can
be applied to $a \colon A$ to obtain $f a : B$.

***** Constructing functions
Given $\Phi$, an expression of type $B$ assuming $x : A$; we can define a function
as

\[
f(x) :\equiv \Phi,
\]

and also as a \lambda-expression, written as

\[
(\lambda (x:A) . \Phi) : A \to B,
\quad
\text{ or even }
\quad
(x \mapsto \Phi) : A \to B.
\]

**** \beta-reduction
*\beta-reduction* is a computation rule defined by

\[
(\lambda x. \Phi) (a) \equiv \Phi',
\]

where every ocurrence of $x$ in $\Phi$ has been replaced by $a$ in $\Phi'$, in a way that
the binding structure is preserved; maybe renaming variables.

**** \eta-reduction
*\eta-reduction*, often called /uniqueness principle for function types/
is the computation rule defined by

\[
f \equiv (\lambda x. f(x)).
\]

**** Currying
*Currying* is a way to define multiple-input functions as functions returning
partially aplied functions. For example, $f : A \to (B \to C)$ can be applied
to two arguments as $(f\ a)\ b : C$.

*** I.1.3. Universes and families
**** Universes
A *universe* is a type whose elements are types.

***** Russell's paradox
As in set theory, a universe of all types including itself, ${\cal U}_{\infty} : {\cal U}_{\infty}$, is
unsound.

***** Hierarchy of universes
A cumulative hierarchy of universes is defined, where every universe
is an elemtn of the next universe, ${\cal U}_i : {\cal U}_{i+1}$; and all the elements of
a universe are elements of all the higher universes.

\[
{\cal U}_0 : {\cal U}_1 : {\cal U}_2 : \dots
\]

*Typical ambiguity* is the writing style where we omit the level unless
it is necessary.

**** Families of types
A *family of types*, is a collection of types varying over a type
variable $A$. They are functions whose codomain is a universe, $f : A \to {\cal U}$.

*** I.1.4. Dependent function types (\Pi-types)
**** Dependent function types
Given $A : {\cal U}$ and $B : A \to {\cal U}$, we construct the type of *dependent functions*
as $\prod_{(x:A)}B(x) : {\cal U}$.

***** Constructing dependent functions
Given $\Phi : B(x)$, a expression assuming $x : A$, we can use \lambda-abstraction
to write

\[
\lambda x . \Phi(x) : \prod_{(x:A)} B(x).
\]

***** Reductions
\beta and \eta-reductions still hold on dependent functions.

**** Polymorphic functions
A *polymorphic function* takes a type as one of its arguments, and acts on
elements of that type.

***** The identity function
The polymorphic identity function $\mathrm{id} : \prod_{(A:{\cal U})} A \to A}$ is defined as
$\mathrm{id} =& \lambda (A:{\cal U}) . \lambda (x:A) . x$.

*** I.1.5. Product types
**** Cartesian product
Given $A,B : {\cal U}$, the *cartesian product type* $A \times B : {\cal U}$ contains pairs
$(a,b) : A \times B$, where $a:A$ and $b:B$. A function on a product type is
defined by

\[
f((a,b)) :\equiv g(a)(b),
\]

where $g : A \to B \to C$.

**** Unit type
The *unit type* $1$ has a unique element $\star : 1$.

**** TODO Introducing new types
**** Product type recursor
The *recursor* for product types symbolizes the fact that we can define a 
function on a product type only by giving its value on pairs,

\[ \mathtt{rec}_{A \times B}(C,g,(a,b)) = g(a)(b),
\]

where it has type

\[ \mathtt{rec}_{A \times B} : \prod_{C : {\cal U}} (A \to B \to C) \to A \times B \to C.
\]

**** TODO Unit type recursor

**** TODO Product type dependent recursor
**** TODO Propositional uniqueness principle
**** Induction principle on product types
The induction principle on product types has type

\[ \mathtt{ind}_{A \times B} :
\prod_{C : A \times B \to {\cal U}}
\left( \prod_{(x:A)} \prod_{(y:B)} C((x,y)) \right) \to
\prod_{(x:A \times B)} C(x)
\]

and defining equation $\mathtt{ind}_{A \times B} (C,g,(a,b)) :\equiv g(a)(b)$.

**** TODO Induction principle on unit types

*** I.1.6. Dependent type pairs (\Sigma-types)
**** TODO Type-theoretic axiom of choice
**** Example: Magmas
We can define a *magma* as

\[ \mathtt{magma} :\equiv
\sum_{A : {\cal U}} A \to A \to A.
\]
*** I.1.7. Coproduct types
**** TODO Coproduct type
**** TODO Empty type
*** I.1.8. The type of booleans
**** TODO if-then-else
**** TODO Coproducts as dependent types
*** I.1.9. The natural numbers
**** TODO Natural numbers
**** Addition
We define $\mathsf{add} : \mathbb{N} \to \mathbb{N} \to \mathbb{N}$ as

 * $\mathsf{add}(0,n) \equiv n$,
 * $\mathsf{add}(\succ(m),n) \equiv \succ(\mathsf{add}(m,n))$.

**** TODO Associativity
*** I.1.10. Pattern matching and recursion
We would like to define a function only writing its /defining equations/.
An example of this is this =double= function

\[\begin{aligned} 
\mathtt{double}(0) &:\equiv 0 \\ 
\mathtt{double}( \mathtt{succ}(n) ) &:\equiv \mathtt{succ} (\mathtt{succ} (\mathtt{double} (n))).
\end{aligned}\]

This style is called *pattern matching*; it is similar to recursion but
it is limited in the recursive calls it can use. Explicitly, it can be used
only as a shorthand for writing a definition using the recursor. Given

\[\begin{aligned} 
f(0) &:\equiv \Phi_0 \\ 
f( \mathtt{succ}(n) ) &:\equiv \Phi_{s},
\end{aligned}\]

we need $\Phi_s$ to depend on $f$ only via $f(n)$ in order to be well-defined as

\[
f :\equiv \mathtt{rec}_{\mathbb{N}} (C,\Phi_0,\lambda n. \lambda r. \Phi'_{s}).
\]

*** I.1.11. Propositions as types
An element of the type corresponding to a proposition is a *witness* or 
a *proof* of the truth of that proposition. From this perspective, proofs
are mathematical objects per se.

# Cite Wadler

**** Falsity and negation

**** Constructive logic
The natural interpretation of propositions-as-types is /constructive/,
meaning that certain tautologies on classical logic, such as the 
*law of excluded middle* (LEM) do not hold.

The logic is still compatible with the presence of the LEM as an axiom.

*** I.1.12. Identity types

\[ \mathtt{refl} : \prod_{a:A} (a =_A a)
\]

** I.2. Homotopy type theory
In homotopy type theory, each type has the structure of an
$\infty\text{-groupoid}$, arising from the induction principle for
identity types.

Homotopy type theory provides a /synthetic/ description of the spaces,
in contrast with the usual analytic approach of topology.

*** 2.1. Types are higher groupoids
**** 2.1.1. Path inverse
Given $x,y : A$, there is a function called *inverse*

\[
(-)^{-1} : (x = y) \to (y = x)
\]

such that $\refl^{-1} = \refl$.

***** Proof
Given $p : x = y$, we apply path induction and then provide $\refl : x = x$.

**** 2.1.2. Path composition
Given $x,y,z : A$, there is a function called *concatenation*

\[
\cdot : (x = y) \to (y = z) \to (x = z)
\]

such that $\refl \cdot \refl = \refl$.

***** First proof
Given $p \cdot q$, we apply path induction on $p$ and $q$. Definitionally,
we can provide an element of $x = x$,

\[
\refl \cdot \refl = \refl
\]

***** Second proof
We apply path induction over $p$, and provide $q$ as an element
of $x = z$. We have $\refl \cdot q \equiv q$.

***** Third proof
We apply path induction over $q$, and provide $p$ as an element
of $x = y$. We have $p \cdot \refl \equiv p$.

***** Proof-relevance and definitional equalities
These three proofs are not definitionally equal, and they provide
different functions with sightly different definitions. In particular,
we get three different definitional equalities

 1) $\refl \cdot \refl \equiv \refl$,

 2) $p \cdot \refl \equiv p$,

 3) $\refl \cdot q \equiv q$;

and, while doing informal mathematics, we will prefer the symmetry of
the first one.

**** TODO 2.1.4. Path operation properties

**** TODO 2.1.6. Eckmann-Hilton
**** 2.1.7. Pointed type
A *pointed type* is a type with a basepoint of that type. That is,
${\cal U}_{\bullet} :\equiv \sum_{A:{\cal U}} A$ is the type of pointed types.

**** 2.1.8. Loop spaces
Given a pointed type $(A,a)$, we define the *loop space* as

\[
\Omega(A,a) :\equiv ((a=a),\refl_a)
\]

and the *n-fold iterated loop space* recursively as

 * $\Omega^0(A,a) :\equiv (A,a)$,

 * $\Omega^{n+1}(A,a) :\equiv \Omega^n(\Omega(A,a))$.

*** 2.2. Functions are functors
**** 2.2.1. Definition of ap
Given $f: A \to B$, there is an operation

\[
\ap_f : x=y \to f(x) = f(y)
\]

such that $\ap_f(\refl) \equiv \refl_{f(x)}$.

***** Notation
We write $\ap_f(p)$ as $f(p)$.

***** Proof
Trivially defined by path induction.

**** 2.2.2. Functioriality of ap
Given $f : A \to B$ and $g : B \to C$ and paths $p : x = y$ and
$q : y = z$, we have

 1) $\ap_f(p \cdot q) = \ap_f(p) \cdot \ap_f(q)$
 2) $\ap_f(p^{-1}) = ap_f(p)^{-1}$
 3) $\ap_g(\ap_f(p)) = \ap_{g \circ f}(p)$
 4) $\ap_{id_A}(p) = p$

***** Proof
Trivial by path induction on $p$.

*** 2.3. Type families are fibrations
**** 2.3.1. Transport
Given $P : A \to {\cal U}$ and $p : x = y$, there exists a function

\[
p_{\ast} : P(x) \to P(y),
\]

such that $\refl_{\ast}$ is the identity.

***** Notation
Sometimes we notate transport as

\[
p_{\ast} \equiv \transport^P(p,-) : P(x) \to P(y).
\]

***** Proof
Applying path induction over $p$, $x \equiv y$ and $\id : P(x) \to P(x)$
is an inhabitant of the type.

**** 2.3.2. Path lifting property
Given $P : A \to {\cal U}$ and $u : P(x)$, for any $p : x = y$,

\[
\mathsf{lift}(u,p) : (x,u) = (y, p_{\ast}(u));
\]

in $\sum_{x:A}P(x)$ such that $\mathsf{pr}_1(\mathsf{lift}(u,p)) = p$.

***** Proof
The first component is given by $p$, the second one can be defined
applying path induction over $p$ and, knowing that $x \equiv y$ and thus,
$u \equiv p_{\ast}(u)$.

**** 2.3.4. Dependent map
Given $f : \prod_{x:A} P(x)$ there exists a map

\[
\apd_f : \prod_{p : x=y} p_{\ast}(f(x)) =_{P(y)} f(y)
\]

***** Proof
Path induction.

**** TODO 2.3.5. Constant transport
**** TODO 2.3.8. Constant plus dependent transport
**** 2.3.9. Transport composition lemma
Given $P : A \to {\cal U}$, $p : x = y$ and $q : y = z$, for $u : P(x)$ we have

\[
q_{\ast}(p_{\ast}(u)) = (p \cdot q)_{\ast} (u).
\]

***** Proof
Double path induction.

**** TODO 2.3.10. Transport precomposition lemma
**** TODO 2.3.11. Naturality of transport
*** 2.4. Homotopies and equivalences
**** 2.4.1. Homotopy
A *homotopy* between $f, g : \prod_{x:A} P(x)$ is a dependent function
of type

\[
(f \sim g) :\equiv \prod_{x:A} f(x) = g(x).
\]

**** 2.4.2. Homotopy is an equivalence relation
Homotopy is an equivalence relation on each dependent function
type $\prod_{x:A} P(x)$. We have elements of

 1) reflexivity

    \[
    \prod_{f:\prod_{x:A} P(x)} (f \sim f)
    \]

 2) symmetry

    \[
    \prod_{f,g : \prod_{x:A}P(x)} (f \sim g) \to (g \sim f)
    \]

 3) transitivity

    \[
    \prod_{f,g,h : \prod_{x:A} P(x)} (f \sim g) \to (g \sim h) \to (f \sim h)
    \]

***** Proof
Given any $f$ and $x$, $\refl$ is of type $f(x) = f(x)$.

Given any $f,g$ such that $f \sim g$, for every $x$, we have an inhabitant of
$f \sim g$. By path induction, it must be $\refl$, so $\refl : g(x) = f(x)$.
 
Given any $f,g,h$ such that $f \sim g$ and $g \sim h$, for every $x$, we
have $f(x) = g(x) = h(x)$, and, in particular $f(x) = h(x)$.

**** 2.4.3. Naturality of homotopies
Given $H : f \sim g$ and $p : x = y$, 

\[
H(x) \cdot g(p) = f(p) \cdot H(y).
\]

As a commutative diagram,

\[\begin{tikzcd}
f(x)\rar[equal]{f(p)} \dar[swap,equal]{H(x)} & 
f(y)\dar[equal]{H(y)} \\
g(x)\rar[equal]{g(p)} &
g(y)
\end{tikzcd}\]


***** Proof
By path induction, $p = \refl$, and $\ap$ computes on reflexivity.

**** 2.4.4. Endonaturality of homotopies
Given $H : f \sim \id_{A}$, for any $x : A$,

\[
H(f(x)) = f(H(x))
\]

***** Proof
By naturality, and knowing that $H(x) : f(x) = x$, 

\[\begin{tikzcd}
f(x)\rar[equal]{f(H(x))} \dar[swap,equal]{H(x)} & 
f(f(x))\dar[equal]{H(f(x))} \\
x\rar[equal]{H(x)} &
f(x)
\end{tikzcd}\]

thus,

\[
f(H(x)) \cdot H(x) = H(f(x)) \cdot H(x),
\]

and then $f(H(x)) = H(f(x))$.

**** 2.4.6. Quasi-inverse
A *quasi-inverse* of $f : A \to B$ is a triple $(g,\alpha,\beta)$ with homotopies
$\alpha : f \circ g \sim \id_B$ and $\beta : g \circ f \sim \id_A$.

\[
\mathsf{qinv}(f) = \sum_{g:B \to A} (f \circ g \sim \id) \times (g \circ f \sim \id).
\]

**** 2.4.9. Transport has a quasi-inverse
The transport $p : x = y$ for $P \colon A \to {\cal U}$,

\[
\mathsf{transport}^P(p,-) : P(x) \to P(y)
\]

has a quasiinverse $\transport^P(p^{-1},-)$.

*** 2.5. Higher groupoid structure of type formers

*** 2.6. Cartesian product types
**** 2.6.2. Cartesian product equalities
For any $x,y$, the function

\[
x = y \to (\proj_1(x) = \proj_1(y)) \times (\proj_2(x) = \proj_2(y))
\]

given by applying projections to the equality, is an equivalence.
We denote the quasiinverse as

\[
\mathsf{pair}^{=} :
(\proj_1(x) = \proj_1(y)) \times (\proj_2(x) = \proj_2(y))
\to
x = y.
\]

***** Proof
We will define a function in the other direction. By induction,
we assume $x \equiv (a,b)$ and $y \equiv (a',b')$; thus we have $a = a'$
and $b = b'$. We apply path induction to both paths and we
get that $(a,b) \equiv (a',b')$.

Now we have to prove that it is a quasiinverse. In one direction,
if we have $r : x = y$, we apply path induction and we get the
pair $(\refl_{\proj_1(x)}, \refl_{\proj_2(x)})$. If we apply induction to $x$, we
get $(\refl_a,\refl_{b})$; our inverse takes this to $\refl_{(a,b)}$.

In the other direction, if we have $p : a = a'$ and $q : b = b'$,
we apply induction to get $\refl_{(a,b)}$; applying a function to
reflexivity gives again $(\refl_a, \refl_b)$.

**** 2.6.4. Cartesian product transport
Given two type families $A,B : Z \to {\cal U}$ and a path $p : z = w$,
for every $x : A(z) \times B(z)$,

\[
p_{\ast}(x) = (\transport^A(p,\proj_1(x)), \transport^B(p,\proj_2(x)))
\]

***** Proof
By path induction, it remains to prove

\[
x = (\proj_1(x), \proj_2(x)),
\]

which is definitionally equal.

**** 2.6.5. Functoriality under cartesian products
Given $x,y : A \times B$, $p,q$ path between components. For every function
defined as $f(x) :\equiv (g(\proj_1(x)), h(\proj_2(x)))$, it holds that

\[
f(\mathsf{pair}^{=}(p,q)) = \mathsf{pair}^{ =}(g(p),h(q)).
\]

***** Proof
We first apply induction over $x$, and then path induction over
$p,q$. We get reflexivity in both sides.

*** 2.7. Sigma types
**** 2.7.2. Sigma type equalities
Given a type family $P : A \to {\cal U}$, there is an equivalence

\[
(w = w') \simeq \sum_{p : \proj_1(w) = \proj_1(w')} 
p_{\ast}(\proj_2(w)) = \proj_2(w'). 
\]

This can be seen as an introduction $\pair^{=}$ and elimination rules
for equalities between dependent pairs.

***** Proof
****** First component of the equivalence
We define the first part of the equivalence depending on
$w,w' : \sum_{x:A}P(x)$, of type

\[
f : \prod_{w,w' : \sum_{x:A}P(x)} 
\left(
(w=w') \to
\sum_{p:\proj_1(w) = \proj_1(w')} p_{\ast}(\proj_2(w)) = \proj_2(w')
\right)
\]

by induction on the path $w = w'$ as

\[
f(w,w,\refl) = (\refl_{\pr_1(w)}, \refl_{\pr_2(w)}).
\]

****** Second component of the equivalence
And we define the second part of the equivalence depending
again on both $w,w'$, of type

\[
g : \prod_{w,w' : \sum_{x:A}P(x)}
\left( \left(
\sum_{p:\pr_1(w) = \pr_1(w')}  
p_{\ast}(\pr_2(w)) = \pr_2(w')
\right)
\to (w = w')
\right)
\]

defined by induction on $w = (x,y)$ and $w' = (x',y')$ first and then on
$p : x = x'$ and $p_{\ast}(y) = y'$, to get

\[
g((x,y),(x,y),\refl,\refl) = \refl_{(x,y)}.
\]

****** First homotopy
Finally, we have to show that they form an equivalence. Given any $w,w'$ and

\[
r : \sum_{p:\pr_1(w) = \pr_1(w')} p_{\ast}(\pr_2(w)) = \pr_2(w'),
\]

we can apply induction over both $w = (x,y)$ and $w' = (x',y')$, and then over
$r$ to get paths $p : x = y$ and $p_{\ast}(y) = y'$. By path induction and the definition
of $f$ and $g$, we get the desired result, $f(g(r)) = r$.

****** Second homotopy
On the other hand, if we have $p : w = w'$, we can directly apply path induction
and use the definitions to get $g(f(p)) = p$.

**** 2.7.3. Sigma equality to its parts
For any $z : \sum_{x:A}P(x)$, we have $z = (\pr_1(z),\pr_2(z))$.

***** Proof
By induction on $z = (x,y)$, we trivially arrive at an
identity path.

# HoTT MAILING LIST !

***** Proof in HoTT book
Applying the [[*2.7.2. Sigma type equalities][previous lemma]], we only have to provide evidence
for the equality of both projections. We trivially have

\[
\pr_1(z) = \pr_1(\pr_1(z),\pr_2(z))
\]

and by judgmental equality, it is trivial that

\[
(\refl_{\pr_1(z)})_{\ast}(\pr_2(z)) = \pr_2(z) = \pr_2(\pr_1(z),\pr_2(z)).
\]

**** 2.7.4. Transport over sigma equalities
Given $P : A \to {\cal U}$ and

\[
Q : \left( \sum_{x:A} P(x) \right) \to {\cal U},
\]

for any path $p : x = y$, and $(u,z) : \sum_{u:P(x)} Q(x,u)$ we have

\[
p_{\ast}(u,z) = 
(p_{\ast}(u), \pair^{=}(p,\refl_{p_{\ast}(u)})_{\ast} (z)).
\]

*** 2.8. The unit type
**** Unit type equality
Given $x,y:1$, we have $(x = y) \simeq 1$.

***** Proof
A function $(x = y) \to 1$ is defined trivially; and given any $x, y : 1$
we now by induction that $x \equiv y$ and we can write a constant function
to $\refl_{\star}$.

Given an element $u : 1$, it is trivial that the composite is an element
of $1$, and therefore both are equal to $\star$. Given an element $p : x = y$,
we can apply path induction to get $p = \refl_{x}$ and induction over $x$ to
get $\refl_{\star}$. As a consequence, $p$ goes to $\refl_{\star}$.

*** 2.9. The function extensionality axiom
**** 2.9.2. happly
There exists a function

\[
\happly : (f = g) \to \prod_{x:A} f(x) = g(x)
\]

defined by path induction.

**** 2.9.3. Function extensionality axiom
The function $\happly$ is an equivalence. It has a quasi-inverse given
by

\[
\funext : \left(\prod_{x:A} f(x) = g(x)\right) \to (f = g).
\]

such that, for any $h : \prod_{x:A} f(x) = g(x)$,

\[
\happly(\funext(h), x) = h(x).
\]

**** TODO 2.9.4. Dependent identity, inverses and composition

**** 2.9.4. Rules for dependent transport
Given $f : A(x) \to B(x)$ and $p : x = y$,

\[
p_{\ast}(f) = p_{\ast}\circ f \circ p^{-1}_{\ast}.
\]

***** Proof
Path induction.

**** 2.9.6. Equivalence for the dependent function equality
Given $A,B : X \to {\cal U}$, $p : x = y$ and two functions $f : A(x) \to B(x)$
and $g : A(y) \to B(y)$, we have an equivalence

\[
(p_{\ast}(f) = g) \simeq \prod_{a:A(x)} p_{\ast}(f(a)) = g(p_{\ast}(a)).
\]

Moreover, given $q : p_{\ast}(f) = g$, we have

\[
\happly(q,p_{\ast}(a)) : (p_{\ast}(f))(p_{\ast}(a)) = g(p_{\ast}(a))
\]

equal to the composite

\[
p_{\ast}(f)(p_{\ast}(a)) = p_{\ast}(f(p^{-1}_{\ast}(p_{\ast}(a))))
= p_{\ast}(f(a)) = g(p_{\ast}(a)).
\]

***** Proof
By path induction on $p$, we arrive to function extensionality.
Computation rule for function extensionality gives us the value
of $\happly$.

**** TODO 2.9.7. Transport equivalence between families
*** 2.10. Universes and the univalence axiom
**** 2.10.1. idtoeqv
Given any types $A,B : {\cal U}$, there is a function

\[
\idtoeqv : (A = B) \to (A \simeq B).
\]

***** TODO Proof

**** 2.10.3. Voevodsky's Univalence Axiom
A universe is univalent if for any $A,B : {\cal U}$, $\idtoeqv$ is an equivalence.
All universes are univalent. There exists

\[\ua : (A \simeq B) \to (A = B),
\]

such that 

\[
\transport(\ua(f), x) = f(x).
\]

**** TODO 2.10.5. Transport and idtoeqv
*** 2.11. Identity type
**** 2.11.1. Aplication of equivalences is an equivalence
If $f : A \to B$ is an equivalence, so is

\[
\mathsf{ap}_f : (a = a') \to (f(a) = f(a')).
\]

***** Proof
Let $f^{-1}$ be a quasiinverse with homotopies

\[
\alpha : \prod_{b:B} f(f^{-1}(b)) = b
\quad\mbox{ and }\quad
\beta : \prod_{a:A}f^{-1}(f(a)) = a.
\]

the quasiinverse of $\ap_f$ will be $\ap_{f^{-1}}$ concatenated with $\beta^{-1}$ and $\beta$.
We will show that this is a quasiinverse. On one direction,

\[
\beta_a^{-1} \cdot \ap_{f^{-1}}(\ap_f(p)) \cdot \beta_{a'} = p
\]

is true by [[*2.4.4. Endonaturality of homotopies][endonaturality of the homotopy]] $\beta$ and functoriality
of the application $\ap_{f^{-1}} \circ \ap_f = \ap_{f^{-1} \circ f}$.

**** 2.11.2. Path transport
Given any $a : A$ with $p : x_1 = x_2$,

 1) for $q : a = x_1$, we have $\transport^{x \mapsto a=x}(p,q) = p_{\ast}(q) = q \cdot p$;
 2) for $q : x_1 = a$, we have $\transport^{x\mapsto x=a}(p,q) = p^{-1} \cdot q$;
 3) for $q : x_1 = x_1$, we have $\transport^{x\mapsto (x=x)}(p,q) = p^{-1} \cdot q \cdot p$.

***** Proof
By path induction on $p$, we get the composition rules for
reflexivity.

*** 2.12. Coproducts
**** 2.12.1. Characterization of equalities for coproducts
Given a coproduct type $A + B$, 

 * $(\inl(a_1) = \inl(a_2)) \simeq (a_1 = a_{2})$,
 * $(\inr(b_1) = \inr(b_2)) \simeq (b_1 = b_2)$,
 * $(\inl(a) = \inr(b)) \simeq 0$.

***** Proof
Given $a_0 : A$ we will characterize the family

\[
(x \mapsto (\inl(a_0) = x)) : A + B \to {\cal U},
\]

using the following type family

 * $\code(\inl(a)) :\equiv (a_0 = a)$,
 * $\code(\inr(a)) :\equiv 0$.

and proving that $(\inl(a_0) = x) \simeq \code(x)$ in the following
[[*2.12.5. Code for coproducts][lemma]]. An analogous family $(x \mapsto (\inr(b_0) = x))$ can be also
characterized.

**** 2.12.5. Code for coproducts
Given $a_0 : A$, for all $x:A+B$, we have $(\inl(a_0) = x) \simeq \code(x)$;
with the definition presented in the previous [[*2.12.1. Characterization of equalities for coproducts][proof]].

***** Proof
We first define a function

\[
\encode : \prod_{(x:A+B)} \prod_{(p : \inl(a_0) = x)} \code(x)
\]

using transport, as $\encode(\inl(a), p) = p_{\ast}(\refl_{a_0})$. Next, we define
a function

\[
\decode : \prod_{(x : A+B)}\prod_{(c : \code(x))} (\inl(a_0) = x)
\]

by induction on $x$ as

 * $\decode(\inl(a), c) :\equiv \ap_{\inl}(c)$,
 * $\decode(\inr(b),c) :\equiv \mathsf{abort}(c)$.

Now, we must prove that they form an equivalence. On the one hand, given
$x : A +B$ and $p : \inl(a_0) = x$, we must show that

\[
\decode(x,\encode(x,p)) = p;
\]

and this can be done by path induction on $p$. On the other hand, given
any $c : \code(x)$, we want to prove that

\[
\encode(x,\decode(x,c)) = c;
\]

and we can proceed by induction on $x$; if $x \equiv \inr(b)$, then we arrive at
a contradiction in $c$; in other case, $x \equiv \inl(a)$ so we can apply path
induction on $c$.

*** 2.13. Natural numbers
**** 2.13.0. Codes for identities on natural numbers
We define $\mathsf{code} \colon \mathbb{N} \to \mathbb{N} \to {\cal U}$ by double recursion as

 * $\code(0,0) :\equiv 1$,
 * $\code(\succ(m),0) :\equiv 0$,
 * $\code(0,\succ(n)) :\equiv 0$,
 * $\code(\succ(m),\succ(n)) :\equiv \code(m,n)$,

and trivially, a diagonal function $r : \prod_{n:\mathbb{N}} \code(n,n)$ by induction.

**** 2.13.1. Equivalence code-identity
We have $(n = m) \simeq \code(m,n)$.

***** Proof
****** Encode function
We define a function $\prod_{m,n \colon \mathbb{N}} (n = m) \to \code(m,n)$ by transport
and using the diagonal $r : \prod_{n:\mathbb{N}} \code(n,n)$.

****** Decode function
We define a function $\prod_{m,n\colon \mathbb{N}} \code(m,n) \to (n = m)$ by double induction
on $n$ and $m$.

 * On the case $n=m=0$, we define a function to $\refl_0$.
 * On the cases where only one of them is zero, we arrive a contradiction.
 * On the case were both are successors, we have an element $\code(m,n)$, so
   we can recursively apply the decode function to it to get $m = n$. Now
   it suffices to use $\ap_{\succ}$.

****** Quasiinverses I
We will show first that given any $p : m = n$,

\[
\decode(n,n,\encode(n,n,\refl)) = \refl,
\]

which is to show $\decode(n,n,r(n)) = \refl$. This can be done by induction
on $n$, where in the case $0$, we get reflexivity and in the successor case,
we use that $\ap(\refl) = \refl$.

****** Quasiinverses II
Given any $c : \code(m,n)$, we can apply double induction.

 * In the zero case, we have a unit type that remains the same after
   encoding.
 * In the only one successor case, we arrive a contradiction.
 * In the both successor cases, 
   \[\begin{aligned}
   \encode&(\succ(m),\succ(n),\decode(\succ(m),\succ(n),c)) \\
     &= \encode(\succ(m),\succ(n),\ap_{\succ}(\decode(m,n,c))) \\
     &= (\ap_{\succ}(\decode(m,n,c)))_{\ast} (r(\succ(m))) \\
     &= (\decode(m,n,c))_{\ast} (r(m)) \\
     &= \encode(m,n,\decode(m,n,c)) \\
     &= c
   \end{aligned}\]
   by induction.

In other words, we can prove that each code is a diagonal and then
apply induction over $\decode(m,n,c)$.

**** 2.13.2. Zero is not a successor
We have that zero is not the successor of any natural number,
in particular

\[
\encode(\succ(m),0) : (\succ(m) = 0) \to 0.
\]

***** Proof
Applying [[*2.13.1. Equivalence code-identity][decode-encode]] directly.

**** 2.13.3. Successor is injective
The sucessor function is injective, in particular

\[
(\succ(m) = \succ(n)) \to (m = n).
\]

***** Proof
We can apply $\encode$ to the equality and get a new code
to which apply $\decode$. Note that

$\encode(\succ(m),\succ(n)) : \code(m,n)$

is well-typed.

*** 2.14. Example: equality of structures
**** 2.14.1. Semigroup structures
The type of *semigroup structures* on $A$ is defined as

\[
\mathsf{SemigroupStr}(A) :\equiv \sum_{(m : A \to A \to A)} \prod_{(x,y,z : A)} m(x,m(y,z)) = m(m(x,y),z)
\]

and a *semigroup* is defined in general as

\[
\mathsf{Semigroup} :\equiv \sum_{A : {\cal U}} \mathsf{SemigroupStr}(A).
\]

**** 2.14.1. Induced structures
Given an equivalence $e : A \simeq B$, we can transport semigroup
structures

\[
(\ua(e))_{\ast} : \mathsf{SemigroupStr}(A) \to \mathsf{SemigroupStr}(B).
\]

Given $(m,a) : \mathsf{SemigroupStr}(A)$, we want to compute

\[
\ua(e)_{\ast} (m,a) : \mathsf{SemigroupStr}(B)
\]

and transporting over a [[*2.7.4. Transport over sigma equalities][coproduct]] is the same as transporting over its
components. We will get some $(m',a')$ where

 * $m'(b_1,b_2) :\equiv (\ua(e)_{\ast}(m))(b_1,b_2)$;

 * $a' :\equiv (\pair^{=}(\ua(e), \refl))_{\ast}\ a$.

By function extensionality, we only have to check the behaviour of
$m'$ given a pair of arguments. We have,
# UA is quasi-inverse to transport^(X \to X)

\[\begin{aligned}
m'(b_1,b_2) &=
\ua(e)_{\ast} (m (\ua(e)_{\ast}^{-1} b_1, \ua(e)_{\ast}^{-1} b_2)) \\
&= e(m(e^{-1}b_1,e^{-1}b_2))
\end{aligned}\]

It can be proved that the transported $a'$ works by algebraic
manipulation using this fact.

*** 2.15. Universal properties
**** 2.15.2. Universal property of the product
There is an equivalence

\[
(X \to A \times B) \simeq (X \to A) \times (X \to B);
\]

given by $f \mapsto (\pr_1 \circ f, \pr_2 \circ f)$.

***** TODO Proof

**** 2.15.5. Dependent universal property of the product
There is an equivalence

\[
\left( \prod_{x:X} A(x) \times B(x) \right) \simeq
\left( \prod_{x:X} A(x) \right) \times 
\left( \prod_{x:X} B(x) \right)
\]

given by $f \mapsto (\pr_1 \circ f, \pr_2 \circ f)$.

***** TODO Proof

**** 2.15.7. Theorem of choice
There is an equivalence

\[
\left( \prod_{x:X}\sum_{(a : A(x))} P(x,a) \right) \simeq
\left( \sum_{g : \prod_{x:X}A(x)} \prod_{x:X} P(x,g(x)) \right)
\]

trivially determined.

***** TODO Proof

**** 2.15.11. Pullbacks
Given $f : A \to C$ and $g : B \to C$, we define the *pullback* as

\[
A \times_C B :\equiv \sum_{(a:A)}\sum_{(b:B)}(f(a) = g(b)).
\]

** I.3. Sets and logic
*** 3.1. Sets and n-types
**** 3.1.1. Sets
A type $A$ is a *set* if every two equalities $p,q : x =_A y$ are equal.

\[
\textsf{isSet}(A) \equiv \prod_{(x,y : A)} \prod_{(p,q : x = y)} p = q.
\]

**** 3.1.6. Dependent product of sets is a set
Given $A$ a set and $B : A \to {\cal U}$ such that each $B(x)$ is a set, $\prod_{x:A} B(x)$ 
is a set.

***** Proof
Suppose $f, g : \prod_{x:A} B(x)$ and $p, q : f = g$. Applying function
extensionality,

 * $p = \mathsf{funext}(\lambda x. \mathsf{happly}(p,x))$,
 * $q = \mathsf{funext}(\lambda x. \mathsf{happly}(q,x))$.

Since $B(x)$ is a set, 

 * $\mathsf{happly}(p,x) : f(x) = g(x)$
 * $\mathsf{happly}(q,x) : f(x) = g(x)$

must be equal. Thus, by function extensionality $(\lambda x. \mathsf{happly}(p,x)) = (\lambda x. \mathsf{happly}(q,x))$,
and applying $\mathsf{funext}$, $p = q$.

**** 3.1.7. 1-types
A type $A$ is a *1-type* if for all $x,y:A$ and $p,q : x = y$ and $r,s : p = q$,
we have $r = s$.

**** 3.1.8. Every set is a 1-type
Every set is a *1-type*.

***** Proof
If we have $x,y : A$, $p,q : x = y$ and $f : \isSet(A)$, then we
can define $g = f(x,y,p)$ by partial application, and

\[
g : \prod_{q : x = y}(p = q);
\]

we can now, given $r : q = q'$, use dependent application to get

\[
\apd_g(r) : r_{\ast}(g(q)) = g(q').
\]

By path transport, that means that $g(q) \cdot r = g(q')$. In particular,
given any two $r,s : p = q$;

\[
g(p) \cdot r = g(q) = g(p) \cdot s
\]

and $r = s$ by cancellation.

**** 3.1.9. Not all types are sets
The universe ${\cal U}$ is not a set.

***** TODO Proof
We take $2$ to be the type of the booleans. There exists a
function $\mathrm{not}\colon 2 \to 2$ which is an equivalence; by univalence,
there exists $\ua(\mathrm{not}) \colon 2 = 2$ which is not $\refl$. If it were
$\refl$, then, by univalence, $0_2 = 1_2$.

*** 3.2. Propositions as types?
**** 3.2.2. Negation of double negation
It is not true that $\neg(\neg A) \to A$ for each $A : {\cal U}$.

***** Proof
Given $f \colon \prod_{A:{\cal U}} \neg(\neg A) \to A$, we will arrive to a contradiction.

Let $p \colon 2 = 2$ be the non-trivial path of the booleans. We know
that $f(2) : \neg\neg 2 \to 2$ and

\[
\apd_f(p) : p_{\ast}(f(2)) = f(2),
\]

applying [[*2.9.4. Rules for dependent transport][rules for dependent transport]], we have

\[
p_{\ast}(f(2))(u) = (p_{\ast} \circ f(2) \circ p_{\ast}^{-1})(u).
\]

Every two $u,v : \neg\neg 2$ are equal by function extensionality; thus

\[
p^{-1}_{\ast}(u) = u
\]

and so

\[
p_{\ast}(f(2)(u)) = p_{\ast}(f(2))(u) = f(2)(u).
\]

We have now that $\fnot(f(2)(u)) = f(2)(u)$, and, at the same time,
it is obvious that $\prod_{x:2} \neg (\fnot(x) = x)$.

**** 3.2.7. Negation of LEM
It is not true that $A + (\neg A)$ for each $A \colon {\cal U}$.

***** Proof
An element of type $\prod_{A:{\cal U}} \neg\neg A \to A$ can be constructed from
an element of type $\prod_{A:{\cal U}} A + (\neg A)$.

*** 3.3. Mere propositions
**** 3.3.1. Mere proposition
A type $P$ is a *mere proposition* when

\[
\isProp(P) : 
\prod_{x,y : P} x = y
\]

is inhabited.

**** 3.3.2. Truth is the only true mere proposition
If $P$ is a mere proposition and $x_0 : P$, then $P \simeq 1$.

***** Proof
A trivial equivalence can be constructed.

**** 3.3.3. Equivalence of connected mere propositions
If $P$ and $Q$ are mere propositions, $P \to Q$ and $Q \to P$
imply $P \simeq Q$.

***** Proof
If $f : P \to Q$ and $g : Q \to P$, then $f(g(x)) = x$ and
$g(f(x)) = x$ because both are mere propositions.

**** 3.3.4. Mere propositions are sets
Every mere proposition is a set.

***** Proof
Given $f : \isProp(A)$, we fix $x : A$ and define $g(y) :\equiv f(x,y)$
of type $\prod_{y : A} x = y$. Given two $y,z : A$ with $p : y = z$, we
have

\[
\apd_g(p) : p_{\ast}(g(y)) = g(z)
\]

hence $g(y) \cdot p = g(z)$, or $p = g(y)^{-1} \cdot g(z)$; thus given $p,q : x = y$
we have $p = g(x)^{-1} \cdot g(y) = q$.

**** 3.3.5. isProp and isSet are mere propositions
Given any type $A$, the types $\isSet(A)$ and $\isProp(A)$ are mere
propositions.

***** Proof
If we have $f,g : \isProp(A)$, we know that $f(x,y) = g(x,y)$ because
$A$ is a mere proposition. By function extensionality, $f = g$.

If we have $f,g : \isSet(A)$ we know that $f(x,y,p,q) = g(x,y,p,q)$
because $x = y$ is a mere proposition from the fact that $A$ is a set.
By function extensionality, $f = g$.

*** 3.4. Classical vs. intuitionistic logic
**** 3.4.1. Law of excluded middle
We define the *law of excluded middle* as

\[
\LEM :\equiv \prod_{A : {\cal U}} \Big( \isProp(A) \to (A + \neg A) \Big)
\]

whereas the usual general law of excluded middle is renamed as

\[
\LEM_{\infty} :\equiv \prod_{A : {\cal U}} (A + \neg A).
\]

The law of excluded middle can be assumed as an axiom.

**** 3.4.3. Decidable types
1. A type is *decidable* if $A + \neg A$.

2. A type family is *decidable* if

   \[
   \prod_{a : A} B(a) + \neg B(a)
   \]

3. A type has *decidable equality* if
   
   \[
   \prod_{a,b : A} (a = b) + \neg (a = b)
   \]

The Law of excluded middle says that all mere propositions are
decidable.

*** 3.5. Subsets and propositional resizing
**** 3.5.1. Uniqueness of dependent sum of mere propositions
Given $P \colon A \to {\cal U}$ such that $P(a)$ is always a mere proposition;
if $u,v \colon \sum_{x:A}P(x)$ are such that $\proj_1(u) = \proj_1(v)$, then
$u = v$.

***** Proof
Given $p : \proj_1(u) = \proj_1(v)$, we only have to show that

\[
p_{\ast}(\proj_2(u)) = \proj_2(v)
\]

and this is true because both are members of $P(\proj_1(v))$, a
mere proposition.

**** 3.5.1. Subtypes
If $P$ is a family of mere propositions, we write

\[
\sum_{x:A} P(x) \equiv \left\{ x : A\mid P(x) \right\}
\]

and call this a *subtype*. We can define membership and subsets
analogously.

***** Subuniverses of sets and mere propositions
We define

 * $\Set_{{\cal U}} :\equiv \left\{ A : {\cal U} \mid \isSet(A) \right\}$,
 * $\Prop_{{\cal U}} :\equiv \left\{ A : {\cal U} \mid \isProp(A) \right\}$.

There are natural maps $\Set_{{\cal U}_i} \to \Set_{{\cal U}_{i+1}}$.

**** 3.5.2. Propositional resizing
*Propositional resizing* is the fact that the natural map
$\Prop_{{\cal U}_i} \to \Prop_{{\cal U}_{i+1}}$ is an equivalence.

Propositional resizing can be taken as an axiom.

***** Omega-indexation of propositions
From propositional resizing follows the existence of $\Omega$, a
type that indexes mere propositions. If propositional resizing
is true, $\Omega :\equiv \Prop_{{\cal U}_0}$.

***** Powersets
If propositional resizing is true, we can define

\[
{\cal P}(A) :\equiv (A \to \Omega),
\]

which is independent of the universe.
*** 3.6. Logic of mere propositions
**** TODO 3.6.1. Product of mere propositions is a mere proposition
**** TODO 3.6.2. Dependent functions to mere propositions are mere propositions
**** TODO 3.6.2. Sums of mere propositions are not mere propositions
*** 3.7. Propositional truncation
**** 3.7.0. Propositional truncation type
For any $A$ there is a *truncation type* $\trunc{A}$, with constructors

 * $|a| : \trunc{A}$ for any $a : A$;
 * $x=y$ for any $x,y : \trunc{A}$;

ensuring that it is a mere proposition.

***** Recursion principle
If $B$ is a mere proposition and $f : A \to B$, then there exists
$g : \trunc{A} \to B$ such that $g(|a|) \equiv f(a)$ for all $a:A$.

**** 3.7.1. Traditional logical notation
We define

 * $\top :\equiv 1$,

 * $\bot :\equiv 0$,

 * $P \land Q :\equiv P \times Q$,

 * $P \lor Q :\equiv \trunc{P + Q}$,

 * $P \Rightarrow Q :\equiv P \to Q$,

 * $P \Leftrightarrow Q :\equiv P = Q$,

 * $\neg P :\equiv P \to 0$,

 * $\forall (x:A). P(x) :\equiv \prod_{x:A} P(x)$,

 * $\exists (x:A).P(x) :\equiv \trunc{\sum_{x:A} P(x)}$.

**** 3.7.2. Traditional set notation
We define

 * $\left\{ x:A\mid P(x) \right\} \cap \left\{ x:A \mid Q(x) \right\} :\equiv \left\{ x:A \mid P(x) \wedge Q(x) \right\}$,
 * $\left\{ x:A \mid P(x) \right\} \cup \left\{ x:A \mid Q(x) \right\} :\equiv \left\{ x:A\mid P(x) \lor Q(x) \right\}$,
 * $A \setminus \left\{ x:A\mid P(x) \right\} :\equiv \left\{ x:A \mid \neg P(x) \right\}$.

Note how the latter are not complements in the absence of LEM.
*** 3.8. The axiom of choice
**** 3.8.1. The axiom of choice
Given a $X$ and type families $A : X \to {\cal U}$, $P : \prod_{x:X} (A(x) \to {\cal U})$
such that $X$ and $A(x)$ are always sets and $P(x,a)$ is always a
mere proposition; the *axiom of choice* asserts

\[
\left( \prod_{x:X} \trunc{\sum_{a:A(x)} P(x,a)} \right)
\to
\trunc{\sum_{(g: \prod_{x:X}A(x))} \prod_{(x:X)} P(x,g(x))}.
\]

In logical notation, this means,

\[
\bigg( \forall (x:X). \exists (a:A(x)). P(x,a) \bigg)
\Rightarrow
\left( \exists \bigg(g: \prod_{x:X}A(x)\bigg). \forall (x:X). P(x,g(x)) \right)
\]

**** 3.8.2. Simpler axiom of choice
The axiom of choice is equivalent to 

\[
\left( \prod_{x:X} \trunc{Y(x)} \right) \to
\trunc{ \prod_{x:X} Y(x) }
\]

for any $X$ and $Y(x)$ always sets.

***** TODO Proof

**** TODO 3.8.5. Counterexample to the simpler version

*** 3.9. The principle of unique choice
**** 3.9.1. Equivalence of mere propositions and truncations
If $P$ is a mere proposition, $P \simeq \trunc{P}$.

***** Proof
We apply the universal property to $\id$ to get $\trunc{P} \to P$;
and we have a $P \to \trunc{P}$ by definition. This [[*3.3.3. Equivalence of connected mere propositions][proves]] an
equivalence of mere propositions.

**** 3.9.2. The principle of unique choice
Given $P \colon A \to {\cal U}$ such that

 * $P(x)$ is always a mere proposition;
 * $\trunc{P(x)}$ is always true.

Then $\prod_{x:A}P(x)$.

***** TODO Proof

*** 3.10. When are propositions truncated?
*** 3.11. Contractibility
**** 3.11.1. Contractible type
A type $A$ is *contractible*, or *singleton* if there is a center of
contraction $a : A$ such that $a = x$ for all $x : A$.

\[
\isContr(A) :\equiv \sum_{a:A}\prod_{x:A}(a = x)
\]

**** 3.11.3. Characterization of contractibility
Given $A$, the following are equivalent

 1. $A$ is contractible,
 2. $A$ is a mere proposition, and there is a point $a:A$,
 3. $A$ is equivalent to $1$.

***** Proof
If $A$ is contractible, it has a point $a : A$ and every two other
points are equal to it.

If $A$ is an inhabited mere proposition, it is equivalent to $1$.

And $1$ is contractible.

**** TODO 3.11.4. Contr is a mere proposition
**** TODO 3.11.5. Contractibility of Contr
**** TODO 3.11.6. Dependent product of contractible types
**** TODO 3.11.7. Retracts and contractibility
**** TODO 3.11.8.
**** TODO 3.11.9.
**** 3.11.10. Mere propositions and contractibility
$A$ is a mere proposition iff for all $x,y : A$, the type $x = y$ is
contractible.

***** TODO Proof
If $A$ is a mere proposition, then $x = y$ must be true; it must be
also a set, so $x=y$ must be contractible.

If $x=y$ is contractible, it is inhabited, so $A$ is a mere
proposition.

** I.4. Equivalences
*** 4.1. Quasi-inverses
**** 4.1.1. Characterization of the quasi-inverse type
If given $f : A \to B$, $\qinv{}(f)$ is inhabited,

\[
\qinv(f) \simeq \prod_{x:A}(x=x)
\]

***** TODO Proof
As $f$ is an equivalence, we apply univalence to get $p : A = B$.
Applying path induction, $p = \refl$ and $f = \id$. Then,

\[
\qinv(\id) \equiv \sum_{g : A \to A} (g \sim \id) \times (\id \sim g)
\]

which is equivalent by function extensionality to

\[
\sum_{g : A \to A} (g = \id) \times (g = \id)
\]

**** 4.1.2. Existence of center
Given $a : A$ and $q : a = a$ such that

 1. $a = a$ is a set,
 2. $\trunc{a = x}$ for all $x : A$,
 3. $p \cdot q = q \cdot p$ for all $p : a = a$,

there exists $f : \prod_{x:A}(x = x)$ such that $f(a) = q$.

***** TODO Proof
**** 4.1.3. qinv is not always a mere proposition
There exists a function such that $\qinv(f)$ is not a mere
proposition.

***** TODO Proof
*** TODO 4.2. Half adjoint equivalences
**** 4.2.1. Half adjoint equivalence
A function $f : A \to B$ is a *half adjoint equivalence* if

\[
\ishae(f) :\equiv
\sum_{(g : B \to A)}
\sum_{(\eta : g \circ f \sim \id_{A})}
\sum_{(\epsilon : f \circ g \sim \id_{B})}
\prod_{(x:A)}
f(\eta(x)) = \epsilon(f(x))
\]

that is, there exist two homotopies and a coherence condition
between them.

**** 4.2.2. Logical equivalence of half adjoint equivalences
Given $f : A \to B$ and $g : B \to A$ with homotopies $\eta : g \circ f \sim \id$ and
$\epsilon : f \circ g \sim \id$, the following two types are logically equivalent

 * $\prod_{x:A}f(\eta(x)) = \epsilon(f(x))$,

 * $\prod_{x:A} g(\epsilon(x)) = \eta(g(x))$.

***** Proof
We will prove the second homotopy from $\tau : \prod_{x:A}f(\eta(x)) = \epsilon(f(x))$;
simmetry gives us the other direction.

By [[*2.4.4. Endonaturality of homotopies][endonaturality of homotopies]] in $\epsilon$ we have

\[\begin{tikzcd}
fgfg(x) \rar[equal]{fg \epsilon(x)} \dar[swap,equal]{\epsilon fg(x)} & 
fg(x) \dar[equal]{\epsilon(x)} \\
fg(x) \rar[equal]{\epsilon(x)} &
x
\end{tikzcd}\]

and applying $g$ to the complete diagram renders

\[\begin{tikzcd}
gfgfg(x) \rar[equal]{gfg\epsilon(x)} \dar[swap,equal]{g\epsilon fg(x)} & 
gfg(x) \dar[equal]{g\epsilon(x)} \\
gfg(x) \rar[equal]{g\epsilon(x)} &
gx
\end{tikzcd}\]

applying now the homotopy $\tau(g(x))$, we get $g \epsilon fg(x) = gf \eta g(x)$;
and again by [[*2.4.4. Endonaturality of homotopies][naturality]], we have $gf \eta g(x) = \eta gfg(x)$, and the
diagram is

\[\begin{tikzcd}
gfgfg(x) \rar[equal]{g fg\epsilon(x)} 
\dar[swap,equal]{\eta gfg(x)} & 
gfg(x) \dar[equal]{g\epsilon(x)} \\
gfg(x) \rar[equal]{g\epsilon(x)} &
gx
\end{tikzcd}\]

Meanwhile, by naturality of $\eta$ between $gfgfg$ and $gfg$, we have that

\[\begin{tikzcd}
gfgfg(x) \rar[equal]{g fg\epsilon(x)} 
\dar[swap,equal]{\eta gfg(x)} & 
gfg(x) \dar[equal]{\eta g(x)} \\
gfg(x) \rar[equal]{g\epsilon(x)} &
gx
\end{tikzcd}\]

and joining both diagrams we get $\eta g(x) = g \epsilon(x)$.

**** 4.2.3. qinv implies ishae
It is obvious that $\ishae$ implies $\qinv$.
For any $f : A \to B$ we have $\qinv(f) \to \ishae(f)$.

***** Proof
Given a quasiinverse $(f,g,\eta,\epsilon)$, we will define a new tuple
$(f,g,\eta,\epsilon',\tau')$; taking $\epsilon'$ to be

\[
\epsilon'(b) :\equiv \epsilon fg(b)^{-1} \cdot f\eta g(b) \cdot \epsilon(b)
\]

so we need to find an homotopy

\[
\tau(a) : f\eta(a) = \epsilon fgf(a)^{-1} \cdot f \eta gf(a) \cdot \epsilon f(a)
\]

but we know by [[*2.4.4. Endonaturality of homotopies][endonaturality]] that $\eta gf(a) = gf \eta(a)$ and by
homotopy that

\[
f \eta gf(a) \cdot \epsilon f(a) = fgf\eta(a) \cdot \epsilon f(a) = \epsilon fgf(a) \cdot f\eta(a).
\]

**** 4.2.4. Fiber of a map
The *fiber* of $f : A \to B$ over a point is

\[
\fib_f(y) :\equiv \sum_{x:A}(f(x) = y).
\]

**** 4.2.5. Equality of fibers
Given $f : A \to B$ and $(x,p), (x',p') : \fib_f(y)$,

\[
((x,p) = (x',p'))
\simeq
\left( \sum_{\gamma : x = x'} f(\gamma) \cdot p' = p \right)
\]

***** TODO Proof
# Path lemmas

**** 4.2.6. Fibers of half-adjoint equivalences are contractible
If $\ishae(f)$ for $f : A \to B$, then $\fib_f(y)$ is contractible for any $y : B$.

***** TODO Proof

**** 4.2.7. Left and right inverses
Given $f : A \to B$ we define

 * its *left inverses*, $\linv(f) :\equiv \sum_{g : B \to A} (g \circ f \sim \id)$,

 * its *right inverses*, $\rinv(f) :\equiv \sum_{g \colon B \to A}(f \circ g \sim \id)$.

*** TODO 4.3. Bi-invertible maps
**** 4.3.1. Bi-invertible
A function $f : A \to B$ is *bi-invertible* if it
[[*4.2.7. Left and right inverses][has left and right inverses]]

\[
\biinv(f) :\equiv \linv(f) \times \rinv(f).
\]

**** 4.3.2. biinv is a mere proposition
The type $\biinv(f)$ is a mere proposition for any $f : A \to B$.

***** TODO Proof

**** 4.3.3. Equivalence biinv and ishae
Given $f : A \to B$, we have $\qinv(f) \simeq \ishae(f)$.

***** TODO Proof
*** TODO 4.4. Contractible fibers
**** 4.4.1. Contractible maps
A function $f : A \to B$ is *contractible* if $\fib_f(y)$ is contractible
for every $y : B$; that is, we define

\[
\isContr(f) :\equiv \prod_{y:B} \isContr(\fib_f(y)).
\]

**** 4.4.3. isContr implies ishae
For any $f : A \to B$, we have $\isContr(f) \to \ishae(f)$.

***** TODO Proof

**** 4.4.4. isContr is a mere proposition
For any $f$, the type $\isContr(f)$ is a mere proposition.

***** TODO Proof
**** 4.4.5. isContr is equivalent to ishae
For any $f : A \to B$, we have $\isContr(f) \simeq \ishae(f)$.

***** TODO Proof
*** 4.5. On the definition of equivalences
We have proved equivalent

\[
\isContr(f) \simeq \ishae(f) \simeq \biinv(f)
\]

so we choose $\isequiv{}(f) :\equiv \ishae(f)$.

*** 4.6. Surjections and embeddings
**** 4.6.0. Isomorphisms
When two sets are equivalent, we say that they is an *isomorphism*
or a *bijection*.

**** 4.6.1. Surjections and embeddings
A function $f : A \to B$ is

 * *surjective* if $\trunc{\fib_f(b)}$ for every $b : B$;
 * *embedding* if $\ap_f : (x=y) \to (f(x) = f(y))$ is an equivalence.

***** Split surjection
We say that a function $f : A \to B$ is a *split surjection* if

\[
\prod_{b:B}\sum_{a:A} f(a) = b.
\]

Note that it is a stronger assertion than being surjective, that
only asks for an inhabitant without constructive evidence.

***** Axiom of choice and split surjections
The [[*3.8.1. The axiom of choice][axiom of choice]] says exactly that every surjection between sets is
split.

**** 4.6.2. Characterization of embeddings
A function $f : A \to B$ between sets is an embedding if and only if

\[
\prod_{x,y:A} f(x) = f(y) \to x = y.
\]

And we say that it is an *injection*.

***** Proof
We apply that $f(x) = f(y)$ and $x = y$ are mere propositions to get
an equivalence from the logical implications.

**** 4.6.3. Equivalence is surjection and embedding
Any function $f : A \to B$ is an equivalence if and only if it is both
surjective and an embedding.

***** TODO Proof

**** 4.6.4. Equivalence is equivalent to surjection and embedding
For any $f : A \to B$,

\[
\isequiv(f) \simeq \isEmbedding(f) \times \isSurjective(f).
\]

*** 4.7. Closure properties of equivalences
**** 4.7.1. The 2-out-of-3 property
If any two $f,g,g\circ f$ are equivalences, so is the third.

***** Proof
Given $g \circ f$ and $g$ equivalences, we show that $(g \circ f)^{-1} \circ g$ is a
quasi-inverse to $f$ because

 * on the one hand,

   \[
   ((g \circ f)^{-1} \circ g) \circ f \sim \id_{A}
   \]

 * on the other hand,

   \[\begin{aligned}
   f \circ (g \circ f)^{-1} \circ g &\sim
   g^{-1} \circ g \circ f \circ (g \circ f)^{-1} \circ g \\
   &\sim g^{-1} \circ g \\
   &\sim \id.
   \end{aligned}\]

In a similar way, we can prove the other two pair of equivalences.

**** 4.7.2. Retracts
A function $g : A \to B$ is a *retract* of $f : X \to Y$ in

\[\begin{tikzcd}
A \rar{s}\dar{g} & X \rar{r}\dar{f} & A\dar{g} \\
B \rar{s'}& Y \rar{r'}& B
\end{tikzcd}\]

if

 * $R : s \circ r \sim \id$,
 * $R' : s' \circ r' \sim \id$,
 * $L : f \circ s \sim s' \circ g$,
 * $K : g \circ r \sim r' \circ f$.
 * a path $H(a)$ witnessing commutativity of

   \[\begin{tikzcd}
   grs(a) \dar[equal,swap]{g(Ra)}\rar[equal]{Ks(a)} & r'fs(a) \dar[equal]{r'(La)} \\
   g(a)  \rar[equal]{R'(ga)^{-1}} & r's'g(a) \\
   \end{tikzcd}\]

**** TODO 4.7.3. Retract of equivalence is equivalence
**** TODO 4.7.5. 
*** TODO 4.8. The object classifier
**** TODO 4.8.1. Fiber of a type family
**** TODO 4.8.2. 
**** 4.8.3. Object classifier
Given any type $B$ there is an equivalence

\[
\chi :
\left( \sum_{A:{\cal U}}(A \to B) \right) \simeq (B \to {\cal U}).
\]

***** TODO Proof
We can define 

 * $\chi((A,f),b) :\equiv \fib_f(b)$

 * $\psi(P) :\equiv \left( \left(\sum_{b:B} P(b) \right), \pr_1 \right)$

and now verify that this constitutes an equivalence.

*** 4.9. Univalence implies function extensionality
We do not assume function extensionality on this section.

**** 4.9.1. Weak function extensionality principle
The *weak function extensionality principle* asserts that,
for any family $P : A \to {\cal U}$,

\[
\left( \prod_{x:A} \isContr(P(x)) \right)
\to
\isContr \left( \prod_{x:A}P(x) \right).
\]

**** 4.9.2. Equivalence on slice objects
If ${\cal U}$ is univalent, $A,B,X : {\cal U}$ and $e : A \simeq B$, there is 
an equivalence

\[
(X \to A) \simeq (X \to B).
\]

***** TODO Proof

**** TODO 4.9.3. 
**** TODO 4.9.5. Weak function extensionality implies function extensionality
The weak function extensionality principle implies the axiom
of [[*2.9.3. Function extensionality axiom][function extensionality]].

***** Proof

** I.5. Induction
*** 5.1. Introduction to inductive types
**** 5.1.1. Uniqueness of functions over the natural numbers
Given $f,g : \prod_{n:\mathbb{N}} E(x)$ with

\[
e_z : E(0)
\quad\text{ and }\quad 
e_s : \prod_{n:\mathbb{N}}E(n) \to E(\succ(n)) 
\]

such that $f(0) = e_z = g(0)$ and

 * $\prod_{n:\mathbb{N}} f(\succ(n)) = e_s(n,f(n))$,
 * $\prod_{n:\mathbb{N}} g(\succ(n)) = e_s(n,g(n))$;

then $f$ and $g$ are equal.

***** Proof
We apply induction on $n$ over the type family $f(n) = g(n)$.
In the base case, $f(0) = g(0)$; and in the successor case,
knowing that $f(n) = g(n)$,

\[
f(\succ(n)) = e_s(n,f(n)) = e_s(n,g(n)) = g(\succ(n)).
\]

**** TODO 5.2. Uniqueness of inductive types
*** TODO 5.3. W-types
*** 5.4. Inductive types are initial algebras
**** 5.4.1. N-algebra
A $\mathbb{N}\text{-algebra}$ is a type with two elements

\[
\mathbb{N}\text{alg} :\equiv \sum_{C:{\cal U}} C \times (C \to C).
\]

**** 5.4.2. N-homomorphism
A $\mathbb{N}\text{-homomorphism}$ between algebras is a function preserving
the zero and successor elements up to path equality

\[
\mathbb{N}\text{Hom}((C,c_0,c_s), (D,d_0,d_s)) :\equiv
\sum_{h \colon C \to D} (h(c_0) = d_0) \times \left( \prod_{c:C} h(c_s(c)) = d_s(h(c)) \right).
\]

**** 5.4.3. Homotopy initial N-algebra
An algebra is homotopy initial if the type of homomorphisms to any
other algebras is contractible; that is

\[
\isHinit_{\mathbb{N}}(I) :\equiv \prod_{C : \mathbb{N}\text{Alg}} \isContr(\mathbb{N}\text{Hom}(I,C)).
\]

**** TODO 5.4.4. Uniqueness of homotopy initial N-algebras

**** TODO 5.4.5. The naturals are an homotopy initial N-algebra
**** TODO 5.4.6. W-algebras
*** TODO 5.5. Homotopy-inductive types
** I.6. Higher inductive types
*** 6.2. Induction principles and dependent paths
**** 6.2.1. Propositional equality by definition
In the case of higher inductive types, we give equalities by
definition that use non-fundamental parts of the type theory,
and so they are propositional instead of judgmental.

We write them as $f(\mathsf{loop}) := \ell$ to indicate this fact.

**** 6.2.2. Notation for dependent paths
We write dependent paths as

\[
(u =^P_p v) :\equiv \transport^P(p,u) = v.
\]

**** 6.2.5. Non-dependent computation rule of the circle
Given $a : A$ with $p : a = a$, there is a function $f : \mathbb{S}^1 \to A$ such
that

 * $f(\base) :\equiv a$,
 * $\ap_f(\mathsf{loop}) :\equiv p$.

***** TODO Proof

*** 6.3. The interval
**** 6.3.0. The interval
We denote $I$ to the type generated by

 * $0_I : I$, a start point,
 * $1_I : I$, an end point,
 * $\seg : 0_I = 1_I$, a segment between points.

***** TODO Induction principle of the interval
***** TODO Recursion principle of the interval
**** 6.3.1. The interval is contractible
The type $I$ is contractible.

***** Proof
We define a function of type $\prod_{i:I}(i = 1)$, by induction over the
interval

 * $f(0) :\equiv \seg$,
 * $f(1) :\equiv \refl_1$,

and $\apd_f(\seg) : \seg_{\ast}(\seg) = \refl$ can be defined knowing
that this type is equivalent to $\seg^{-1} \cdot \seg = \refl$, and
that path inverse is an inhabitant.

**** TODO 6.3.2. Extensionality from the interval type

*** TODO 6.4. Circles and spheres
*** 6.5. Suspensions
**** 6.5.0. Suspension of a type
The *suspension* of a type $A$ is a type $\Sigma A$ defined by the
generators

 * north, $\N : \Sigma A$;

 * south, $S : \Sigma A$;

 * and meridians, $\merid : A \to (\N = \S)$.

***** TODO Induction principle

**** 6.5.1. Circle as suspension
The circle can be seen as the suspension of the booleans,

\[
\Sigma 2 \simeq \mathbb{S}^{1}.
\]

***** TODO Proof

*** TODO 6.6. Cell complexes

*** TODO 6.7. Hubs and spokes
** I.7. Homotopy n-types
*** 7.1. Definition of n-types
**** 7.1.1. is-n-type
We define $\istype{n} : {\cal U} \to {\cal U}$ as

\[
\istype{n}(X) :\equiv
\left\{\begin{array}{ll}
\isContr(X) & \mbox{if } n = -2, \\
\prod_{x,y:X} \istype{n'}(x = y) & \mbox{if } n = n' + 1.
\end{array}\right.
\]

**** TODO 7.1.4. Retraction of an n-type
**** TODO 7.1.5. Equivalence preserves n-types
*** 7.2. Uniqueness of identity proofs and Hedberg's theorem
**** TODO 7.2.0. Uniqueness of identity proofs (UIP)

**** 7.2.1. Axiom K
A type $A$ is a set if and only if it satisfies *Axiom K*, for
all $x:X$ and $p : x = x$, we have $p = \refl$.

***** TODO Proof

**** 7.2.2. Mere identity relations in sets
Given $R$ a reflexive mere relation on $X$ implying identity, $X$
is a set and $R(x,y) \simeq (x = y)$ for all $x,y :X$.

***** Proof
Given $\rho : \prod_{x:X}R(x,x)$ and $f : \prod_{x,y}R(x,y) \to (x = y)$, we have
that if $X$ is a set, $x = y$ is a mere proposition logically equivalent
to $R(x,y)$. On the other hand, if $x = y$ is equivalent to $R(x,y)$ and
it is a mere proposition, $X$ is a set.

We can give two proofs, either proving that $X$ is a set or that $R(x,y)$
is equivalent to $x = y$.

****** X is a set
Given $x:X$ and $p : x = x$, we consider

\[
\apd_{f(x)}(p) : p_{\ast}(f(x,x)) = f(x,x)
\]

which, by [[*2.9.6. Equivalence for the dependent function equality][path equalities for dependent functions]] gives us a path

\[
p_{\ast}(f(x,x,r)) = f(x,x,p_{\ast}(r)).
\]

Knowing that $R(x,x)$ is a mere proposition, $p_{\ast}(r) = r$; and transport
in the identity type is equal to concatenation, so

\[
f(x,x,r) \cdot p = f(x,x,r)
\]

and $p = \refl$, satisfying axiom K.

****** TODO R is equivalent to equality

**** 7.2.3. A type with double negation cancellation equality is a set
If $X$ has the property $\neg\neg (x=y) \to (x=y)$, it is a set.

***** Proof
We have $\neg\neg(x=y)$ as a reflexive mere relation implying identity,
so we can apply the previous [[*7.2.2. Mere identity relations in sets][lemma]].

**** 7.2.5. Hedberg's theorem
If a type has [[*3.4.3. Decidable types][decidable]] equality, it is a set.

***** TODO Proof.

**** TODO 7.2.6. Natural numbers form a set
The type of natural numbers has decidable equality, and hence is a set.

***** TODO Proof
Given $x,y : \mathbb{N}$, we proceed by induction in both arguments. In the first
case, $\refl_0$ proves the equality; in the case of a successor and a zero,
we can apply 

*** 7.5. Connectedness
**** 7.5.1. n-connected function
A function $f : A \to B$ is *n-connected* if $\trunc{\fib_f(b)}_n$ is
contractible for all $b : B$.

\[
\conn_n(f) :\equiv \prod_{b:B} \isContr(\trunc{\fib_f(b)}_n)
\]

A type $A$ is *n-connected* if the function $A \to 1$ is.

**** TODO 7.5.2. Surjectivity is (-1)-connectedness
A function is (-1)-connected iff it is [[*4.6.1. Surjections and embeddings][surjective]].

* Part II
** II.8. Homotopy theory
*** 8.0. Homotopy theory
**** 8.0.1. Homotopy groups
We define the *homotopy groups* of a pointed type $(A,a)$ as

\[
\pi_n(A,a) :\equiv \trunc{\Omega^n(A,a)}_{0}.
\]

*** 8.1. Fundamental group of the circle
**** 8.1.1. Universal cover of the circle
We define $\mathsf{code} : \mathbb{S}^1 \to {\cal U}$ by recursion as

 * $\mathsf{code}(\mathsf{base}) :\equiv \mathbb{Z}$,
 * $\mathsf{code}(\mathsf{loop}) :\equiv \ua(\succ)$.

**** 8.1.2. Lemma of code transport
We have that

 * $\transport^{\mathsf{code}}(\mathsf{loop},x) = x + 1$,
 * $\transport^{\mathsf{code}}(\mathsf{loop},x) = x -1$.

***** TODO Proof

**** 8.1.5. Encode
We define the function $\mathsf{encode} : \prod_{x:\mathbb{S}^1}(\base = x) \to \mathsf{code}(x)$ by

\[
\mathsf{encode}\ p :\equiv \transport^{\mathsf{code}}(p,0).
\]

**** 8.1.6. Decode
We can define a function $\mathsf{decode} : \prod_{x:\mathbb{S}^1} \mathsf{code}(x) \to (\base = x)$.

***** TODO Definition
**** 8.1.7. Encode-decode of a path
For all $x : \mathbb{S}^1$ and $p : \base = x$,

\[
\mathsf{decode}(\mathsf{encode}(p)) = p.
\]

***** TODO Proof

*** TODO 8.2. Connectedness of suspensions
** II.9. Category theory
** II.10. Set theory
** II.11. Real numbers
*** 11.2. Dedekind reals
**** 11.2.1. Dedekind cuts
A *Dedekind cut* is a pair $(L,U)$ of mere predicates such that
it is

 1) /inhabited:/ $\exists (q : \mathbb{Q}). L(q)$ and $\exists (r : \mathbb{Q}) . U(r)$;

 2) /rounded:/ for all $q,r \in \mathbb{Q}$,

    * $L(q) \iff \exists (r : \mathbb{Q}). (q < r) \wedge L(r)$

    * $U(r) \iff \exists(q:\mathbb{Q}).(q < r) \wedge U(q)$

 3) /disjoint:/ $\neg (Lq \wedge Uq)$ for all $q:\mathbb{Q}$,

 4) /located:/ $(q < r) \implies Lq \vee Ur$ for all $q,r : \mathbb{Q}$.

We define $\mathsf{isCut}(L,U)$ as the mere proposition of the conjunction
of these conditions. The set of *Dedekind reals* is defined as

\[
\mathbb{R}_d :\equiv
\left\{ (L,U) : (\mathbb{Q} \to \Omega) \times (\mathbb{Q} \to \Omega)
\mid \isCut(L,U) \right\}.
\]

**** TODO 11.2.1. Rational embedding

**** TODO 11.2.3. Weak linearity

**** TODO 11.2.3. Apartness
Two Dedekind reals $x,y : \mathbb{R}_d$ are *apart* when

\[
(x \# y) :\equiv (x < y) \vee (y < x).
\]

**** 11.2.4. Invertibility
A real is invertible iff it is apart from 0.

***** TODO Proof

* Exercises
** 1. Exercises: Type theory [5/11]
*** DONE Exercise 1.1
#+begin_statement
Given functions $f : A \to B$ and $g : B \to C$, define their composite
$g \circ f : A \to C$. Show that we have $h \circ (g \circ f) \equiv (h \circ g) \circ f$.
#+end_statement

We define

\[
g \circ f :\equiv \lambda x.g(f(x))
\]

and thus

\[\begin{aligned}
h \circ (g \circ f) &:\equiv \lambda x. h((g \circ f)(x)) \\ 
&\equiv \lambda x. h((\lambda y.g(f(y)))(x)) \\
&\equiv \lambda x. h(g(f(x))) \\
&\equiv \lambda x. (\lambda y. h(g(y)))(f(x)) \\
&\equiv (h \circ g) \circ f.
\end{aligned}\]

*** TODO Exercise 1.2
*** TODO Exercise 1.3
*** TODO Exercise 1.4
#+begin_statement
Assuming as given only the iterator for natural numbers

\[
\mathsf{iter} : \prod_{C:{\cal U}} C \to (C \to C) \to \mathbb{N} \to C.
\]

with the defining equations

 * $\mathsf{iter}(C,c_0,c_s,0) :\equiv c_{0}$,
 * $\mathsf{iter}(C,c_0,c_s,\succ(n)) :\equiv c_s(\mathsf{iter}(C,c_0,c_s,n))$,

....
#+end_statement

*** TODO Exercise 1.5
*** DONE Exercise 1.10
#+begin_statement
Show that the Ackermann function $\mathsf{ack} : \mathbb{N} \to \mathbb{N} \to \mathbb{N}$ is definable using
only $\mathsf{rec}_{\mathbb{N}}$ satisfying the following equations

 * $\mathsf{ack}(0,n) \equiv \mathsf{succ}(n)$,

 * $\mathsf{ack}( \mathsf{succ}(m),0) \equiv \mathsf{ack}(m,1)$,

 * $\mathsf{ack}(\mathsf{succ}(m), \mathsf{succ}(n)) \equiv \mathsf{ack}(m, \mathsf{ack}(\succ(m),n)$.
#+end_statement

We can define

\[
\rec_{\mathbb{N}}\ \succ\ 
(\lambda m. \lambda a_m. 
\rec_{\mathbb{N}}\ (a_m\ 1)\ (\lambda n. \lambda a_{mn}. a_m\ a_{mn})
)
\]

where we can take $a_{m}$ to mean the $\mathsf{ack}$ function partially applied to $m$,
whereas we can take $a_{mn}$ to mean $\mathsf{ack}(m,n)$. With these definitions, we
have the base and successor equalities judgmentally.

*** DONE Exercise 1.11
#+begin_statement
Show that for any type $A$ we have $\neg\neg\neg A \to \neg A$.
#+end_statement

We write the function 

\[
\lambda f. \lambda a. f (\lambda h. h(a)) : \neg\neg\neg A \to \neg A
\]

where $f : \neg\neg\neg A$, $h : \neg A$ and $(\lambda h. h(a)) : \neg\neg A$.

*** DONE Exercise 1.12
#+begin_statement
Using the propositions as types interpretation, derive the
following tautologies

 1) if A, then (if B then A);
 2) if A, then not (not A);
 3) if (not A or not B), then not (A and B).
#+end_statement

We define the following terms

 * $\lambda a.\lambda b.a : A \to (B \to A)$;
 * $\lambda a.\lambda f.f(a) : A \to \neg\neg A$;
 * $\lambda u. \rec(u, \lambda f.\lambda (a,b).f(a), \lambda g.\lambda (a,b). g(b))$;

with the desired types.

*** DONE Exercise 1.13
#+begin_statement
Using propositions-as-types, derive the double negation of the principle
of excluded middle, i.e., prove /not (not (P or not P))/.
#+end_statement

We can define a function

\[
(\lambda f. f (\inr (\lambda p. f (\inl (p))))) 
\]

whose type is $\neg (\neg (P \vee \neg P))$ for any given $P$.

*** TODO Exercise 1.15
*** TODO Exercise 1.16
#+begin_statement
Show that addition of natural numbers is commutative,

\[
\prod_{i,j : \mathbb{N}} i + j = j + i.
\]
#+end_statement

We proceed by induction on $i$. In the first case, we have to
prove $\prod_{j : \mathbb{N}} 0 + j = j + 0$; and this can be done by induction
on $j$. In fact,

 * $\mathsf{commzero}(0) = \refl_0$,
 * $\mathsf{commzero}(S(n)) = \ap_{\succ}(\mathsf{commzero}(n))$.

** 2. Exercises: Homotopy type theory [3/17]
*** TODO Exercise 2.1
#+begin_statement
Show that the three obvious proofs of Lemma 2.1.2 are pairwise equal.
#+end_statement

*** TODO Exercise 2.2
*** TODO Exercise 2.3
*** TODO Exercise 2.4
*** TODO Exercise 2.5
*** TODO Exercise 2.6
*** TODO Exercise 2.7
*** TODO Exercise 2.8
*** TODO Exercise 2.9
*** DONE Exercise 2.10
#+begin_statement
Prove that \Sigma-types are associative, in that for any $A : {\cal U}$ and
families $B : A \to {\cal U}$ and $C : \left(\sum_{x:A} B(x)\right) \to {\cal U}$, we have

\[
\left( \sum_{x:A}\sum_{y:B(x)} C(x,y) \right)
\simeq
\left( \sum_{p : \sum_{x:A}B(x)} C(p) \right)
\]
#+end_statement

We first define a function

\[
f : \left( \sum_{x:A}\sum_{y:B(x)} C(x,y) \right)
\to
\left( \sum_{p : \sum_{x:A}B(x)} C(p) \right)
\]

by induction on the argument, as

\[
f (x,y,c) :\equiv ((x,y),c).
\]

Now we have to prove that this is an equivalence with two homotopies,
with an inverse defined by induction

\[
g((x,y),c) :\equiv (x,y,c).
\]

In fact, given any $(x,y,c)$, or any $((x,y),c)$ it is trivial to check
that there exist two homotopies. Note how we use induction to get the
constructors of the pair.
*** TODO Exercise 2.11
#+begin_statement
A homotopy commutative square

\[\begin{tikzcd}
P\rar{h} \dar[swap]{k} & A \dar{f} \\
B\rar{g} & C
\end{tikzcd}\]

consists of functions $f,g,h$ and $k$ as shown, together with a path $f \circ h = g \circ k$.
Note that this is exactly an element of the pullback $(P \to A) \times_{(P \to C)} (P \to B)$
as defined in (2.15.11). A commutative square is called a (homotopy)
*pullback square* if for any $X$, the induced map

\[
(X \to P) \to (X \to A) \times_{(X \to C)} (X \to B)
\]

is an equivalence. Prove that the pullback $P :\equiv A \times_C B$ defined in (2.15.11)
is the corner of a pullback square.
#+end_statement

*** TODO Exercise 2.12
*** DONE Exercise 2.13
#+begin_statement
Show that $(2 \simeq 2) \simeq 2$.
#+end_statement

We have $(2 \simeq 2)$ with two possible elements determined by the function
given by $2 \to 2$. If we take $\id : 2 \to 2$, that is a trivial equivalence,
and if we take $\neg : 2 \to 2$ we have a different equivalence. 

Now, given any function $f : 2 \to 2$, we can apply induction to both
$f(1)$ and $f(0)$ and then, by function extensionality, assert that it
has to be a constant function or some of the previous equivalences.
We only have two possible equivalences then.

We declare a function taking $\id$ to $\mathsf{true}$ and $\neg$ to $\mathsf{false}$, the inverse
is trivially defined.

*** DONE Exercise 2.14
#+begin_statement
Suppose we add to type theory the equality reflection rule which says
that if there is an element $p : x = y$, then in fact $x \equiv y$. Prove that
for any $p : x = x$ we have $p \equiv \refl$.
#+end_statement

Given any $p : x = y$, we have $x \equiv y$, and we can prove the (well-typed!)
equality $p = \refl$ by path induction. Note that we have used the equality
reflection rule to prove that 

\[
\prod_{x,y : A}\prod_{p : x=y} p = \refl_x
\]

is actually well-typed.

*** TODO Exercise 2.15
*** TODO Exercise 2.16
#+begin_statement
Suppose that rather than function extensionality (Axiom 2.9.3),
we suppose only the existence of an element

\[
\mathsf{funext} : \prod_{A:{\cal U}} \prod_{B:A \to {\cal U}} \prod_{f,g : \prod_{x:A}B(x)} (f \sim g) \to (f = g).
\]
#+end_statement

*** TODO Exercise 2.18
#+begin_statement
State and prove a version of Lemma 2.4.3 for dependent functions.
#+end_statement

** 3. Exercises: Sets and logic [2/8]
*** DONE Exercise 3.1
#+begin_statement
Prove that if $A \simeq B$ and $A$ is a set, then so is $B$.
#+end_statement

The equivalence gives us a pair of functions $f : A \to B$ and $g : B \to A$
with homotopies $\eta : g \circ f \sim \id$ and $\epsilon : f \circ g \sim \id$. By naturality of
$\eta$ we have, for any two paths $p,q : x =_B y$, that

\[\begin{tikzcd}
fg(x)\rar[equal]{fg(p)} \dar[swap,equal]{\eta_x} & 
fg(y)\dar[equal]{\eta_y} \\
x \rar[equal]{p} &
y
\end{tikzcd}\]

and

\[\begin{tikzcd}
fg(x)\rar[equal]{fg(q)} \dar[swap,equal]{\eta_x} & 
fg(y)\dar[equal]{\eta_y} \\
x \rar[equal]{q} &
y
\end{tikzcd}\]

but $g(p) = g(q)$ because $A$ is a set, so $fg(p) = fg(q)$ and therefore, $p=q$.

*** DONE Exercise 3.2
#+begin_statement
Prove that if $A$ and $B$ are sets, then so is $A + B$.
#+end_statement

Note that $A + B = \prod_{x:2} C(x)$ for some family $C$, and we know that the
[[*3.1.6. Dependent product of sets is a set][dependent product of sets is a set]].

*** TODO Exercise 3.3
*** TODO Exercise 3.4
#+begin_statement
Show that $A$ is a mere proposition if and only if $A \to A$ is
contractible.
#+end_statement

*** TODO Exercise 3.5
#+begin_statement
Show that $\isProp(A) \simeq (A \to \isContr(A))$.
#+end_statement

*** TODO Exercise 3.6
#+begin_statement
Show that if $A$ is a mere proposition, then so is $A + (\neg A)$. Thus,
there is no need to insert a propositional truncation in 3.4.1.
#+end_statement

*** TODO Exercise 3.9
#+begin_statement
Show that if $\LEM$ holds, then the type $\Prop :\equiv \sum_{A:{\cal U}} \isProp(A)$
is equivalent to $2$.
#+end_statement

*** TODO Exercise 3.21
#+begin_statement
Prove that $\isProp(P) \simeq (P \simeq \trunc{P})$.
#+end_statement

** 4. Exercises: Equivalences [0/0]

